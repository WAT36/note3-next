---
title: "優先度付きキュー（ヒープ）とPythonで実装するライブラリ「heapq」について"
date: "2019-11-09T03:01:30+09:00"
excerpt: "優先度付きキュー（ヒープ）とPythonで実装するライブラリ「heapq」について"
tag: ["Python"]
updatedAt: "2019-11-09T03:01:30+09:00"
author:
  name: Tatsuroh Wakasugi
  picture: "/assets/blog/authors/WAT.jpg"
---

※この記事は Qiita にも投稿されています： [優先度付きキュー（ヒープ）と Python で実装するライブラリ「heapq」について](https://qiita.com/T_Wakasugi/items/dac6eb77a3cace54f95e)

先日 Atcoder Beginner Contest 141 に参加してきたが、D 問題がいくらやっても TLE になり詰まった挙句 TIME UP になった。

原因はリストから最大値を取り出してくる箇所。

リストから最大値を取り出し、２で割って（点以下切り捨て）再度リストに格納、という動作をループで回す必要があったのだが、いくら直しても TLE になり続けた。

自分が考えていた方法としては

- リストの最大値を取る組み込み関数 max() を使う
- リストをソート ( sort() ) して一番後のインデックスにある要素（＝最大値）を取る

だったのだが、いずれの場合も時間がかかってしまうらしい。

どのようにすれば良かったのか・・？

解説を見て学んだのが "優先度付きキュー" というアルゴリズム。

この優先度付きキューについて、調べて見た。

# 優先度付きキュー

優先度付きキュー (Priority Queue) とは以下の操作が行えるデータ構造。

- キューに数 （要素）を優先度付きで追加する。
- 最も高い優先度を持つ要素を取り出す（値を取得し、削除する）

これを二分木（ヒープ）を用いて効率的に実現したデータ構造の事を言う。

ヒープの特性上、優先度付きキューにおいて最も高い優先度を持つ要素とは最小値のことになり、

優先度付きキューとは最小値を取り出す事の出来るデータ構造と言うことになる。

## ヒープとは

ではヒープ（二分木）とは何か？

> ヒープとは、「子要素は親要素より常に大きいか等しい（または常に小さいか等しい）」と言う制約を持つ木構造の事。単に「ヒープ」という場合、二分木を使った二分ヒープを指すことが多いため、そちらを参照すること。
> ヒープは最小値（または最大値）を求めるのに適した木構造の一種であり、「子要素は親要素より常に大きいか等しい（または常に小さいか等しい）」と言う制約を持つ。子要素が複数ある場合、子要素間の大小関係に制約はない。
> （Wikipedia より）

図に表すと以下のような構造を持つデータ構造である。

![](/assets/note/programming/301_procon/heapq/heap_example.png)

図にある通り、ヒープの特徴としては「子要素は親要素より常に大きいか等しい」と言うところである。

また、ヒープは上から下へ、左から右へ順にノードが詰まっていく。

「子要素は親要素より常に大きいか等しい」と言う定義から、ヒープの一番親の要素（根）は、ヒープで一番小さい値(最小値)ということになる。

### データの挿入

ヒープにデータを挿入すると、入力したデータはまずヒープの最後尾に追加され、親要素と大小を比較し、親要素よりも大きくなるまで上に上げていく。（下図）

![](/assets/note/programming/301_procon/heapq/heap_insert.png)

### データの削除

ヒープからデータを削除（＝最小値を削除）した時は、根の位置に最後尾の要素を持っていき、その後子要素と大小を比較していずれの子要素よりも小さくなるまで下に下げていく。（下図）

![](/assets/note/programming/301_procon/heapq/heap_delete.png)

## Python での優先度付きキュー

ではこのヒープ及び優先度付きキューをプログラミングで実装するにはどうすれば良いのか？

今回も私が現在競プロでよく使用している Python で考えてみることにした。

しかし、調べてみると何と優先度付きキューも Python ではライブラリが実装されているそうだ。

それがこの **heapq** と言うライブラリで、このライブラリについて調べて見た。

### バージョン

Python : 3.7.4

## heapq

heapq ライブラリの諸関数を以下に記載する。

### heapify

heapify 関数はリストをヒープに変換する関数である。

```python
>>> import heapq
>>> a = [7,5,3,2,4,8,10,1]
>>>
>>> a
[7, 5, 3, 2, 4, 8, 10, 1]
>>>
>>> heapq.heapify(a)
>>>
>>> a
[1, 2, 3, 5, 4, 8, 10, 7]
```

変換し作成されたヒープはリストを使って表現される。

このリストでのヒープの見方は、リストのインデックスを k とした時、

- 親要素 : リスト[k]
- 子要素 : リスト[2k+1]、リスト[2k+2]

となる。

### heappush,heappop

heappush 関数は要素をヒープに push する関数である。  
push された要素は前述のヒープ挿入例に基づき、ヒープ内で要素が移動され、最終的にヒープ内で親子間の大小が保たれた形で保持される。  
対して、heappop 関数はヒープから要素を取り出し取得する関数である。  
なお、heappop で取り出すのはヒープにおける最小の要素である。  
heappop 後のヒープは heappush の時と同様に前述のヒープ削除例に基づき、ヒープ内で要素が移動され、最終的にヒープ内で親子間の大小が保たれた形で保持される。  
使用例を以下に示す。

```python
>>>
>>> import heapq
>>> a=[5,3,2,1,6,13,4,12,14,9,10]
>>> heapq.heapify(a)
>>>
>>> a
[1, 3, 2, 5, 6, 13, 4, 12, 14, 9, 10]
>>>
>>> heapq.heappush(a,7)  #7をヒープにプッシュ
>>>
>>> a
[1, 3, 2, 5, 6, 7, 4, 12, 14, 9, 10, 13]
>>>
>>> heapq.heappop(a) #ヒープから要素をpop
1
>>> #最小の要素(1)がヒープからpopされる
>>>
>>> a
[2, 3, 4, 5, 6, 7, 13, 12, 14, 9, 10]
>>>
```

### heappushpop,heapreplace

heappushpop 関数は heappush と heappop を同時に行う関数である。  
順序としては heappush を行ってから heappop を行う。  
heapreplace 関数はその逆で heappop と heappush を同時に行うと言う点では同じだが、  
順序は heappop を行ってから heappush を行う。  
公式によると heappush と heappop を別々に行うよりも、これらの関数を使う方が効率的に行えるとの事。  
使用例を以下に示す。

```python
>>> import heapq
>>> a=[5,3,2,1,6,13,4,12,14,9,10]
>>> heapq.heapify(a)
>>>
>>>
>>> a
[1, 3, 2, 5, 6, 13, 4, 12, 14, 9, 10]
>>>
>>>
>>> heapq.heappushpop(a,11)
1
>>>
>>> a
[2, 3, 4, 5, 6, 13, 11, 12, 14, 9, 10]
>>>
>>> heapq.heappushpop(a,1)
1
>>>
>>> a
[2, 3, 4, 5, 6, 13, 11, 12, 14, 9, 10]
>>>
>>> heapq.heapreplace(a,7)
2
>>>
>>> a
[3, 5, 4, 7, 6, 13, 11, 12, 14, 9, 10]
>>>
>>> heapq.heapreplace(a,1)
3
>>>
>>> a
[1, 5, 4, 7, 6, 13, 11, 12, 14, 9, 10]
>>>
```

heappushpop,heapreplace は push と pop を行う順序から、pop した時に取り出される要素は最小の要素でない場合もあると言うことに注意する。  
上記の例でいうと、ヒープにヒープのどの要素よりも小さい要素を push した時、heappushpop の場合は要素を push してから pop するため push した要素が pop されるが、  
heapreplace はヒープから pop してから要素を push するため、pop される要素は push する前のヒープの最小値であり、また動作後のヒープは push した要素が最小値となったヒープになる。

## ヒープから最大値を取り出すには？

ヒープはその特性上、最小値しか取り出すことはできない。  
もし、最大値を取り出したいといった時はどうするか？

方法の一例としては、要素の符号を全て逆転（-1 を掛ける）させてからヒープを組ませる。  
すると、そのヒープの最小値には元の最大値 ×(-1)した要素が来る。  
その要素を取り出して(pop)また符号を逆転（-1 を掛ける）させてやれば、最終的には最大値を取り出すことが可能となる。

```python
>>> import heapq
>>> #リスト（ヒープ）aから最大値を取り出す。最大値は14
>>> a=[5,3,2,1,6,13,4,12,14,9,10]
>>>
>>> #要素に全て-1をかけて符号を逆転する
>>> a=[-1 * i for i in a]
>>> a
[-5, -3, -2, -1, -6, -13, -4, -12, -14, -9, -10]
>>>
>>> heapq.heapify(a)
>>> a
[-14, -12, -13, -5, -10, -2, -4, -3, -1, -9, -6]
>>> #元の最大値×(-1)させた-14がヒープの最小値に来る
>>>
>>> #ヒープから最小値を取り出し-1を掛ける
>>> heapq.heappop(a) * -1
14
>>> #元の最大値14が取り出された
```

今後活用する機会があれば利用していきたい。
