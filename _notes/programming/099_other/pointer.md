---
title: "ポインタ"
excerpt: ""
tag: ["Go"]
programming: ["Go"]
date: "2025-05-28T20:41:38.000Z"
updatedAt: "2025-05-28T20:41:38.000Z"
tag: []
author:
  name: Tatsuroh Wakasugi
  picture: "/assets/blog/authors/WAT.jpg"
mode: programming
---

ポインタについてを記載する。

<div class="note_content_by_programming_language" id="note_content_Go">

```go
// ポインタ型
var 変数名 *型名

// 任意の型からポインタ型を生成する
&変数

// ポインタ型から値を参照する
*ポインタ型変数

// メソッド（構造体に関連づけられた関数）の定義
func (レシーバ 型) メソッド名(引数...) 戻り値 {

}
```

Go ではポインタ型は「\*int」のようにポインタを使って参照・操作する型の前に「 \* 」をおくことで定義できます。初期値は nil になります。

```go
var p *int
```

また、演算子 **&** を使って、任意の型からそのポインタ型を生成する事ができます。

```go
var i int
p := &i
```

ポインタ型変数からその値を参照するには、演算子\*をポインタ型変数の前に置くことで、値を参照する事ができる。これを**デリファレンス**という。

```go
var i int
p := *i
fmt.Println(*p) // pが指す値を参照する
```

ポインタ型は配列に対しても利用可能です。

```go
p := &[3]int{1,2,3}
fmt.Println((*p)[0]) // 1
```

ポインタ型の変数にはメモリ上のアドレスの値が入っています。

fmt.Printf の「%p」で表示するとそのアドレスを表示させる事ができます。

```go
i := 5
ip := &i
fmt.Printf("%p",ip) // 0xc000010090 など
```

ポインタ型はさまざまな型に対して取る事ができますが、例えば文字列の string に対してインデックス指定した値にポインタをとるとエラーになります。

それは Go では一度生成された文字列に対して変更を加える事ができないからです。ポインタによって値を変えられないように、このような動作は禁止しています。

```go
s := "ABC"
&s      // 文字列sのポインタ
s[0]    // 文字列のインデックス参照
&s[0]   // エラー発生
```

# new 関数

指定した型のポインタ型を生成するために、組み込み関数**new**が用意されている。

`new 型名`という形式で使用する。（主に構造体で使用する。）

しかしアドレス演算子&を使用した複合リテラルによる構造体型のポインタ生成の間には、動作上ほとんど違いはないため、プログラムの状況に応じて使い分けるべきである。

```go
type Point struct {
  X,Y int
}

// pは*Point型
p := new(Point)
p.X = 1
p.Y = 2

// 上記の動作は以下と同じ
p := & Point{X:1,Y:2}
```

# メソッド

Go には**メソッド**という、構造体に関連づけられた関数という機能がある。このメソッドは Java などのようなメソッドを意味しているものではないので注意。

オブジェクト指向言語でいう「インスタンスメソッド」に近く、特定の型の変数に対して操作を行う関数である。

メソッド定義では、関数とは異なり func とメソッド名の間に**レシーバー**の定義が必要となり、型と変数名を明記する。

型に定義されたメソッドは`レシーバー.メソッド`という形式で呼び出すことができる。

以下に例を記載する。以下でレシーバーは値型とポインタ型の２つあるが、値型の方は構造体の値がコピーされて利用されるため、構造体の値の更新をしても元の構造体に反映されないので注意すること。その動作をしたい場合は、ポインタ県の方を使う。

```go
type Point struct {
  X,Y int
}
point := Point{X:5,Y:12}

func (p Point) Display() {
  fmt.Printf("(%d,%d)",p.X,p.Y)
}
point.Display() //(5,12)

func (p *Point) Move() {
  p.X++
  p.Y++
}
(&point).Move()
point.Display() //(6,13)
```

</div>
