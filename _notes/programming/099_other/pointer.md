---
title: "ポインタ"
excerpt: ""
tag: ["Go"]
programming: ["Go"]
date: "2025-05-28T20:41:38.000Z"
updatedAt: "2025-05-28T20:41:38.000Z"
tag: []
author:
  name: Tatsuroh Wakasugi
  picture: "/assets/blog/authors/WAT.jpg"
mode: programming
---

ポインタについてを記載する。

<div class="note_content_by_programming_language" id="note_content_Go">

```go
// ポインタ型
var 変数名 *型名

// 任意の型からポインタ型を生成する
&変数

// ポインタ型から値を参照する
*ポインタ型変数
```

Go ではポインタ型は「\*int」のようにポインタを使って参照・操作する型の前に「 \* 」をおくことで定義できます。初期値は nil になります。

```go
var p *int
```

また、演算子 **&** を使って、任意の型からそのポインタ型を生成する事ができます。

```go
var i int
p := &i
```

ポインタ型変数からその値を参照するには、演算子\*をポインタ型変数の前に置くことで、値を参照する事ができる。これを**デリファレンス**という。

```go
var i int
p := *i
fmt.Println(*p) // pが指す値を参照する
```

ポインタ型は配列に対しても利用可能です。

```go
p := &[3]int{1,2,3}
fmt.Println((*p)[0]) // 1
```

ポインタ型の変数にはメモリ上のアドレスの値が入っています。

fmt.Printf の「%p」で表示するとそのアドレスを表示させる事ができます。

```go
i := 5
ip := &i
fmt.Printf("%p",ip) // 0xc000010090 など
```

ポインタ型はさまざまな型に対して取る事ができますが、例えば文字列の string に対してインデックス指定した値にポインタをとるとエラーになります。

それは Go では一度生成された文字列に対して変更を加える事ができないからです。ポインタによって値を変えられないように、このような動作は禁止しています。

```go
s := "ABC"
&s      // 文字列sのポインタ
s[0]    // 文字列のインデックス参照
&s[0]   // エラー発生
```

# new 関数

指定した型のポインタ型を生成するために、組み込み関数**new**が用意されている。

`new 型名`という形式で使用する。（主に構造体で使用する。）

しかしアドレス演算子&を使用した複合リテラルによる構造体型のポインタ生成の間には、動作上ほとんど違いはないため、プログラムの状況に応じて使い分けるべきである。

```go
type Point struct {
  X,Y int
}

// pは*Point型
p := new(Point)
p.X = 1
p.Y = 2

// 上記の動作は以下と同じ
p := & Point{X:1,Y:2}
```

</div>
