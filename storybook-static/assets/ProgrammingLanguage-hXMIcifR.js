import{R as Z}from"./index-BmQQ4wML.js";import{h as qo}from"./index-Bdewl5Tg.js";var Dn={};function Zo(e){const t=new Error(e);if(t.stack===void 0)try{throw t}catch{}return t}var Yo=Zo,M=Yo;function Xo(e){return!!e&&typeof e.then=="function"}var K=Xo;function Jo(e,t){if(e!=null)return e;throw M(t??"Got unexpected null or undefined")}var j=Jo;function V(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}class dt{getValue(){throw M("BaseLoadable")}toPromise(){throw M("BaseLoadable")}valueMaybe(){throw M("BaseLoadable")}valueOrThrow(){throw M(`Loadable expected value, but in "${this.state}" state`)}promiseMaybe(){throw M("BaseLoadable")}promiseOrThrow(){throw M(`Loadable expected promise, but in "${this.state}" state`)}errorMaybe(){throw M("BaseLoadable")}errorOrThrow(){throw M(`Loadable expected error, but in "${this.state}" state`)}is(t){return t.state===this.state&&t.contents===this.contents}map(t){throw M("BaseLoadable")}}class Qo extends dt{constructor(t){super(),V(this,"state","hasValue"),V(this,"contents",void 0),this.contents=t}getValue(){return this.contents}toPromise(){return Promise.resolve(this.contents)}valueMaybe(){return this.contents}valueOrThrow(){return this.contents}promiseMaybe(){}errorMaybe(){}map(t){try{const n=t(this.contents);return K(n)?Ee(n):De(n)?n:Ze(n)}catch(n){return K(n)?Ee(n.next(()=>this.map(t))):ft(n)}}}class er extends dt{constructor(t){super(),V(this,"state","hasError"),V(this,"contents",void 0),this.contents=t}getValue(){throw this.contents}toPromise(){return Promise.reject(this.contents)}valueMaybe(){}promiseMaybe(){}errorMaybe(){return this.contents}errorOrThrow(){return this.contents}map(t){return this}}class Un extends dt{constructor(t){super(),V(this,"state","loading"),V(this,"contents",void 0),this.contents=t}getValue(){throw this.contents}toPromise(){return this.contents}valueMaybe(){}promiseMaybe(){return this.contents}promiseOrThrow(){return this.contents}errorMaybe(){}map(t){return Ee(this.contents.then(n=>{const o=t(n);if(De(o)){const r=o;switch(r.state){case"hasValue":return r.contents;case"hasError":throw r.contents;case"loading":return r.contents}}return o}).catch(n=>{if(K(n))return n.then(()=>this.map(t).contents);throw n}))}}function Ze(e){return Object.freeze(new Qo(e))}function ft(e){return Object.freeze(new er(e))}function Ee(e){return Object.freeze(new Un(e))}function Pn(){return Object.freeze(new Un(new Promise(()=>{})))}function tr(e){return e.every(t=>t.state==="hasValue")?Ze(e.map(t=>t.contents)):e.some(t=>t.state==="hasError")?ft(j(e.find(t=>t.state==="hasError"),"Invalid loadable passed to loadableAll").contents):Ee(Promise.all(e.map(t=>t.contents)))}function xn(e){const n=(Array.isArray(e)?e:Object.getOwnPropertyNames(e).map(r=>e[r])).map(r=>De(r)?r:K(r)?Ee(r):Ze(r)),o=tr(n);return Array.isArray(e)?o:o.map(r=>Object.getOwnPropertyNames(e).reduce((a,i,u)=>({...a,[i]:r[u]}),{}))}function De(e){return e instanceof dt}const nr={of:e=>K(e)?Ee(e):De(e)?e:Ze(e),error:e=>ft(e),loading:()=>Pn(),all:xn,isLoadable:De};var Ae={loadableWithValue:Ze,loadableWithError:ft,loadableWithPromise:Ee,loadableLoading:Pn,loadableAll:xn,isLoadable:De,RecoilLoadable:nr},or=Ae.loadableWithValue,rr=Ae.loadableWithError,ar=Ae.loadableWithPromise,sr=Ae.loadableLoading,ir=Ae.loadableAll,lr=Ae.isLoadable,cr=Ae.RecoilLoadable,Ye=Object.freeze({__proto__:null,loadableWithValue:or,loadableWithError:rr,loadableWithPromise:ar,loadableLoading:sr,loadableAll:ir,isLoadable:lr,RecoilLoadable:cr});const xt={RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED:!0,RECOIL_GKS_ENABLED:new Set(["recoil_hamt_2020","recoil_sync_external_store","recoil_suppress_rerender_in_callback","recoil_memory_managament_2020"])};function ur(e,t){var n,o;const r=(n=Dn[e])===null||n===void 0||(o=n.toLowerCase())===null||o===void 0?void 0:o.trim();if(r==null||r==="")return;if(!["true","false"].includes(r))throw M(`process.env.${e} value must be 'true', 'false', or empty: ${r}`);t(r==="true")}function dr(e,t){var n;const o=(n=Dn[e])===null||n===void 0?void 0:n.trim();o==null||o===""||t(o.split(/\s*,\s*|\s+/))}function fr(){var e;typeof process>"u"||((e=process)===null||e===void 0?void 0:e.env)!=null&&(ur("RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED",t=>{xt.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED=t}),dr("RECOIL_GKS_ENABLED",t=>{t.forEach(n=>{xt.RECOIL_GKS_ENABLED.add(n)})}))}fr();var Xe=xt;function ht(e){return Xe.RECOIL_GKS_ENABLED.has(e)}ht.setPass=e=>{Xe.RECOIL_GKS_ENABLED.add(e)};ht.setFail=e=>{Xe.RECOIL_GKS_ENABLED.delete(e)};ht.clear=()=>{Xe.RECOIL_GKS_ENABLED.clear()};var F=ht;function hr(e,t,{error:n}={}){return null}var vr=hr,ie=vr,Vt,$t,Mt;const pr=(Vt=Z.createMutableSource)!==null&&Vt!==void 0?Vt:Z.unstable_createMutableSource,On=($t=Z.useMutableSource)!==null&&$t!==void 0?$t:Z.unstable_useMutableSource,Gt=(Mt=Z.useSyncExternalStore)!==null&&Mt!==void 0?Mt:Z.unstable_useSyncExternalStore;let fn=!1;function _r(){var e;const{ReactCurrentDispatcher:t,ReactCurrentOwner:n}=Z.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,r=((e=t==null?void 0:t.current)!==null&&e!==void 0?e:n.currentDispatcher).useSyncExternalStore!=null;return Gt&&!r&&!fn&&(fn=!0,ie()),r}function mr(){return F("recoil_transition_support")?{mode:"TRANSITION_SUPPORT",early:!0,concurrent:!0}:F("recoil_sync_external_store")&&Gt!=null?{mode:"SYNC_EXTERNAL_STORE",early:!0,concurrent:!1}:F("recoil_mutable_source")&&On!=null&&typeof window<"u"&&!window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE?F("recoil_suppress_rerender_in_callback")?{mode:"MUTABLE_SOURCE",early:!0,concurrent:!0}:{mode:"MUTABLE_SOURCE",early:!1,concurrent:!1}:F("recoil_suppress_rerender_in_callback")?{mode:"LEGACY",early:!0,concurrent:!1}:{mode:"LEGACY",early:!1,concurrent:!1}}var Ht={createMutableSource:pr,useMutableSource:On,useSyncExternalStore:Gt,currentRendererSupportsUseSyncExternalStore:_r,reactMode:mr};class jt{constructor(t){V(this,"key",void 0),this.key=t}toJSON(){return{key:this.key}}}class Bn extends jt{}class zn extends jt{}function yr(e){return e instanceof Bn||e instanceof zn}var vt={AbstractRecoilValue:jt,RecoilState:Bn,RecoilValueReadOnly:zn,isRecoilValue:yr},Sr=vt.AbstractRecoilValue,gr=vt.RecoilState,Rr=vt.RecoilValueReadOnly,br=vt.isRecoilValue,Te=Object.freeze({__proto__:null,AbstractRecoilValue:Sr,RecoilState:gr,RecoilValueReadOnly:Rr,isRecoilValue:br});function wr(e,...t){}var Er=wr,Fn=Er;function Tr(e,t){return function*(){let n=0;for(const o of e)yield t(o,n++)}()}var pt=Tr;class Wn{}const Ar=new Wn,Ue=new Map,qt=new Map;function Nr(e){return pt(e,t=>j(qt.get(t)))}function Lr(e){if(Ue.has(e)){const t=`Duplicate atom key "${e}". This is a FATAL ERROR in
      production. But it is safe to ignore this warning if it occurred because of
      hot module replacement.`;console.warn(t)}}function Cr(e){Xe.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED&&Lr(e.key),Ue.set(e.key,e);const t=e.set==null?new Te.RecoilValueReadOnly(e.key):new Te.RecoilState(e.key);return qt.set(e.key,t),t}class Vr extends Error{}function $r(e){const t=Ue.get(e);if(t==null)throw new Vr(`Missing definition for RecoilValue: "${e}""`);return t}function Mr(e){return Ue.get(e)}const ct=new Map;function kr(e){var t;if(!F("recoil_memory_managament_2020"))return;const n=Ue.get(e);if(n!=null&&(t=n.shouldDeleteConfigOnRelease)!==null&&t!==void 0&&t.call(n)){var o;Ue.delete(e),(o=Kn(e))===null||o===void 0||o(),ct.delete(e)}}function Ir(e,t){F("recoil_memory_managament_2020")&&(t===void 0?ct.delete(e):ct.set(e,t))}function Kn(e){return ct.get(e)}var _e={recoilValues:qt,registerNode:Cr,getNode:$r,getNodeMaybe:Mr,deleteNodeConfigIfPossible:kr,setConfigDeletionHandler:Ir,getConfigDeletionHandler:Kn,recoilValuesForKeys:Nr,DefaultValue:Wn,DEFAULT_VALUE:Ar};function Dr(e,t){t()}var Ur={enqueueExecution:Dr};function Pr(e,t){return t={exports:{}},e(t,t.exports),t.exports}var xr=Pr(function(e){var t=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(l){return typeof l}:function(l){return l&&typeof Symbol=="function"&&l.constructor===Symbol&&l!==Symbol.prototype?"symbol":typeof l},n={},o=5,r=Math.pow(2,o),a=r-1,i=r/2,u=r/4,d={},f=function(s){return function(){return s}},p=n.hash=function(l){var s=typeof l>"u"?"undefined":t(l);if(s==="number")return l;s!=="string"&&(l+="");for(var h=0,m=0,y=l.length;m<y;++m){var S=l.charCodeAt(m);h=(h<<5)-h+S|0}return h},g=function(s){return s-=s>>1&1431655765,s=(s&858993459)+(s>>2&858993459),s=s+(s>>4)&252645135,s+=s>>8,s+=s>>16,s&127},D=function(s,h){return h>>>s&a},L=function(s){return 1<<s},E=function(s,h){return g(s&h-1)},$=function(s,h,m,y){var S=y;if(!s){var N=y.length;S=new Array(N);for(var T=0;T<N;++T)S[T]=y[T]}return S[h]=m,S},Q=function(s,h,m){var y=m.length-1,S=0,N=0,T=m;if(s)S=N=h;else for(T=new Array(y);S<h;)T[N++]=m[S++];for(++S;S<=y;)T[N++]=m[S++];return s&&(T.length=y),T},te=function(s,h,m,y){var S=y.length;if(s){for(var N=S;N>=h;)y[N--]=y[N];return y[h]=m,y}for(var T=0,A=0,I=new Array(S+1);T<h;)I[A++]=y[T++];for(I[h]=m;T<S;)I[++A]=y[T++];return I},w=1,U=2,Y=3,z=4,G={__hamt_isEmpty:!0},q=function(s){return s===G||s&&s.__hamt_isEmpty},re=function(s,h,m,y){return{type:w,edit:s,hash:h,key:m,value:y,_modify:Ve}},ye=function(s,h,m){return{type:U,edit:s,hash:h,children:m,_modify:$e}},J=function(s,h,m){return{type:Y,edit:s,mask:h,children:m,_modify:P}},ue=function(s,h,m){return{type:z,edit:s,size:h,children:m,_modify:B}},Ce=function(s){return s===G||s.type===w||s.type===U},X=function(s,h,m,y,S){for(var N=[],T=y,A=0,I=0;T;++I)T&1&&(N[I]=S[A++]),T>>>=1;return N[h]=m,ue(s,A+1,N)},le=function(s,h,m,y){for(var S=new Array(h-1),N=0,T=0,A=0,I=y.length;A<I;++A)if(A!==m){var H=y[A];H&&!q(H)&&(S[N++]=H,T|=1<<A)}return J(s,T,S)},be=function l(s,h,m,y,S,N){if(m===S)return ye(s,m,[N,y]);var T=D(h,m),A=D(h,S);return J(s,L(T)|L(A),T===A?[l(s,h+o,m,y,S,N)]:T<A?[y,N]:[N,y])},de=function(s,h,m,y,S,N,T,A){for(var I=S.length,H=0;H<I;++H){var se=S[H];if(m(T,se.key)){var oe=se.value,fe=N(oe);return fe===oe?S:fe===d?(--A.value,Q(s,H,S)):$(s,H,re(h,y,T,fe),S)}}var he=N();return he===d?S:(++A.value,$(s,I,re(h,y,T,he),S))},Se=function(s,h){return s===h.edit},Ve=function(s,h,m,y,S,N,T){if(h(N,this.key)){var A=y(this.value);return A===this.value?this:A===d?(--T.value,G):Se(s,this)?(this.value=A,this):re(s,S,N,A)}var I=y();return I===d?this:(++T.value,be(s,m,this.hash,this,S,re(s,S,N,I)))},$e=function(s,h,m,y,S,N,T){if(S===this.hash){var A=Se(s,this),I=de(A,s,h,this.hash,this.children,y,N,T);return I===this.children?this:I.length>1?ye(s,this.hash,I):I[0]}var H=y();return H===d?this:(++T.value,be(s,m,this.hash,this,S,re(s,S,N,H)))},P=function(s,h,m,y,S,N,T){var A=this.mask,I=this.children,H=D(m,S),se=L(H),oe=E(A,se),fe=A&se,he=fe?I[oe]:G,Me=he._modify(s,h,m+o,y,S,N,T);if(he===Me)return this;var nt=Se(s,this),Oe=A,Be=void 0;if(fe&&q(Me)){if(Oe&=~se,!Oe)return G;if(I.length<=2&&Ce(I[oe^1]))return I[oe^1];Be=Q(nt,oe,I)}else if(!fe&&!q(Me)){if(I.length>=i)return X(s,H,Me,A,I);Oe|=se,Be=te(nt,oe,Me,I)}else Be=$(nt,oe,Me,I);return nt?(this.mask=Oe,this.children=Be,this):J(s,Oe,Be)},B=function(s,h,m,y,S,N,T){var A=this.size,I=this.children,H=D(m,S),se=I[H],oe=(se||G)._modify(s,h,m+o,y,S,N,T);if(se===oe)return this;var fe=Se(s,this),he=void 0;if(q(se)&&!q(oe))++A,he=$(fe,H,oe,I);else if(!q(se)&&q(oe)){if(--A,A<=u)return le(s,A,H,I);he=$(fe,H,G,I)}else he=$(fe,H,oe,I);return fe?(this.size=A,this.children=he,this):ue(s,A,he)};G._modify=function(l,s,h,m,y,S,N){var T=m();return T===d?G:(++N.value,re(l,y,S,T))};function c(l,s,h,m,y){this._editable=l,this._edit=s,this._config=h,this._root=m,this._size=y}c.prototype.setTree=function(l,s){return this._editable?(this._root=l,this._size=s,this):l===this._root?this:new c(this._editable,this._edit,this._config,l,s)};var v=n.tryGetHash=function(l,s,h,m){for(var y=m._root,S=0,N=m._config.keyEq;;)switch(y.type){case w:return N(h,y.key)?y.value:l;case U:{if(s===y.hash)for(var T=y.children,A=0,I=T.length;A<I;++A){var H=T[A];if(N(h,H.key))return H.value}return l}case Y:{var se=D(S,s),oe=L(se);if(y.mask&oe){y=y.children[E(y.mask,oe)],S+=o;break}return l}case z:{if(y=y.children[D(S,s)],y){S+=o;break}return l}default:return l}};c.prototype.tryGetHash=function(l,s,h){return v(l,s,h,this)};var _=n.tryGet=function(l,s,h){return v(l,h._config.hash(s),s,h)};c.prototype.tryGet=function(l,s){return _(l,s,this)};var C=n.getHash=function(l,s,h){return v(void 0,l,s,h)};c.prototype.getHash=function(l,s){return C(l,s,this)},n.get=function(l,s){return v(void 0,s._config.hash(l),l,s)},c.prototype.get=function(l,s){return _(s,l,this)};var R=n.has=function(l,s,h){return v(d,l,s,h)!==d};c.prototype.hasHash=function(l,s){return R(l,s,this)};var k=n.has=function(l,s){return R(s._config.hash(l),l,s)};c.prototype.has=function(l){return k(l,this)};var b=function(s,h){return s===h};n.make=function(l){return new c(0,0,{keyEq:l&&l.keyEq||b,hash:l&&l.hash||p},G,0)},n.empty=n.make();var x=n.isEmpty=function(l){return l&&!!q(l._root)};c.prototype.isEmpty=function(){return x(this)};var W=n.modifyHash=function(l,s,h,m){var y={value:m._size},S=m._root._modify(m._editable?m._edit:NaN,m._config.keyEq,0,l,s,h,y);return m.setTree(S,y.value)};c.prototype.modifyHash=function(l,s,h){return W(h,l,s,this)};var ee=n.modify=function(l,s,h){return W(l,h._config.hash(s),s,h)};c.prototype.modify=function(l,s){return ee(s,l,this)};var O=n.setHash=function(l,s,h,m){return W(f(h),l,s,m)};c.prototype.setHash=function(l,s,h){return O(l,s,h,this)};var ne=n.set=function(l,s,h){return O(h._config.hash(l),l,s,h)};c.prototype.set=function(l,s){return ne(l,s,this)};var me=f(d),ce=n.removeHash=function(l,s,h){return W(me,l,s,h)};c.prototype.removeHash=c.prototype.deleteHash=function(l,s){return ce(l,s,this)};var ae=n.remove=function(l,s){return ce(s._config.hash(l),l,s)};c.prototype.remove=c.prototype.delete=function(l){return ae(l,this)};var tt=n.beginMutation=function(l){return new c(l._editable+1,l._edit+1,l._config,l._root,l._size)};c.prototype.beginMutation=function(){return tt(this)};var ln=n.endMutation=function(l){return l._editable=l._editable&&l._editable-1,l};c.prototype.endMutation=function(){return ln(this)};var xo=n.mutate=function(l,s){var h=tt(s);return l(h),ln(h)};c.prototype.mutate=function(l){return xo(l,this)};var Nt=function(s){return s&&cn(s[0],s[1],s[2],s[3],s[4])},cn=function(s,h,m,y,S){for(;m<s;){var N=h[m++];if(N&&!q(N))return un(N,y,[s,h,m,y,S])}return Nt(S)},un=function(s,h,m){switch(s.type){case w:return{value:h(s),rest:m};case U:case z:case Y:var y=s.children;return cn(y.length,y,0,h,m);default:return Nt(m)}},Oo={done:!0};function Lt(l){this.v=l}Lt.prototype.next=function(){if(!this.v)return Oo;var l=this.v;return this.v=Nt(l.rest),l},Lt.prototype[Symbol.iterator]=function(){return this};var Ct=function(s,h){return new Lt(un(s._root,h))},Bo=function(s){return[s.key,s.value]},zo=n.entries=function(l){return Ct(l,Bo)};c.prototype.entries=c.prototype[Symbol.iterator]=function(){return zo(this)};var Fo=function(s){return s.key},Wo=n.keys=function(l){return Ct(l,Fo)};c.prototype.keys=function(){return Wo(this)};var Ko=function(s){return s.value},Go=n.values=c.prototype.values=function(l){return Ct(l,Ko)};c.prototype.values=function(){return Go(this)};var dn=n.fold=function(l,s,h){var m=h._root;if(m.type===w)return l(s,m.value,m.key);for(var y=[m.children],S=void 0;S=y.pop();)for(var N=0,T=S.length;N<T;){var A=S[N++];A&&A.type&&(A.type===w?s=l(s,A.value,A.key):y.push(A.children))}return s};c.prototype.fold=function(l,s){return dn(l,s,this)};var Ho=n.forEach=function(l,s){return dn(function(h,m,y){return l(m,y,s)},null,s)};c.prototype.forEach=function(l){return Ho(l,this)};var jo=n.count=function(l){return l._size};c.prototype.count=function(){return jo(this)},Object.defineProperty(c.prototype,"size",{get:c.prototype.count}),e.exports?e.exports=n:(void 0).hamt=n});class Or{constructor(t){V(this,"_map",void 0),this._map=new Map(t==null?void 0:t.entries())}keys(){return this._map.keys()}entries(){return this._map.entries()}get(t){return this._map.get(t)}has(t){return this._map.has(t)}set(t,n){return this._map.set(t,n),this}delete(t){return this._map.delete(t),this}clone(){return Yt(this)}toMap(){return new Map(this._map)}}class Zt{constructor(t){if(V(this,"_hamt",xr.empty.beginMutation()),t instanceof Zt){const n=t._hamt.endMutation();t._hamt=n.beginMutation(),this._hamt=n.beginMutation()}else if(t)for(const[n,o]of t.entries())this._hamt.set(n,o)}keys(){return this._hamt.keys()}entries(){return this._hamt.entries()}get(t){return this._hamt.get(t)}has(t){return this._hamt.has(t)}set(t,n){return this._hamt.set(t,n),this}delete(t){return this._hamt.delete(t),this}clone(){return Yt(this)}toMap(){return new Map(this._hamt)}}function Yt(e){return F("recoil_hamt_2020")?new Zt(e):new Or(e)}var Br={persistentMap:Yt},zr=Br.persistentMap,Fr=Object.freeze({__proto__:null,persistentMap:zr});function Wr(e,...t){const n=new Set;e:for(const o of e){for(const r of t)if(r.has(o))continue e;n.add(o)}return n}var hn=Wr;function Kr(e,t){const n=new Map;return e.forEach((o,r)=>{n.set(r,t(o,r))}),n}var vn=Kr;function Gr(){return{nodeDeps:new Map,nodeToNodeSubscriptions:new Map}}function Hr(e){return{nodeDeps:vn(e.nodeDeps,t=>new Set(t)),nodeToNodeSubscriptions:vn(e.nodeToNodeSubscriptions,t=>new Set(t))}}function kt(e,t,n,o){const{nodeDeps:r,nodeToNodeSubscriptions:a}=n,i=r.get(e);if(i&&o&&i!==o.nodeDeps.get(e))return;r.set(e,t);const u=i==null?t:hn(t,i);for(const d of u)a.has(d)||a.set(d,new Set),j(a.get(d)).add(e);if(i){const d=hn(i,t);for(const f of d){if(!a.has(f))return;const p=j(a.get(f));p.delete(e),p.size===0&&a.delete(f)}}}function jr(e,t,n,o){var r,a,i,u;const d=n.getState();o===d.currentTree.version||o===((r=d.nextTree)===null||r===void 0?void 0:r.version)||o===((a=d.previousTree)===null||a===void 0?void 0:a.version)||ie();const f=n.getGraph(o);if(kt(e,t,f),o===((i=d.previousTree)===null||i===void 0?void 0:i.version)){const g=n.getGraph(d.currentTree.version);kt(e,t,g,f)}if(o===((u=d.previousTree)===null||u===void 0?void 0:u.version)||o===d.currentTree.version){var p;const g=(p=d.nextTree)===null||p===void 0?void 0:p.version;if(g!==void 0){const D=n.getGraph(g);kt(e,t,D,f)}}}var Je={cloneGraph:Hr,graph:Gr,saveDepsToStore:jr};let qr=0;const Zr=()=>qr++;let Yr=0;const Xr=()=>Yr++;let Jr=0;const Qr=()=>Jr++;var _t={getNextTreeStateVersion:Zr,getNextStoreID:Xr,getNextComponentID:Qr};const{persistentMap:pn}=Fr,{graph:ea}=Je,{getNextTreeStateVersion:Gn}=_t;function ta(){const e=Gn();return{version:e,stateID:e,transactionMetadata:{},dirtyAtoms:new Set,atomValues:pn(),nonvalidatedAtoms:pn()}}function na(){const e=ta();return{currentTree:e,nextTree:null,previousTree:null,commitDepth:0,knownAtoms:new Set,knownSelectors:new Set,transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:new Map().set(e.version,ea()),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}}var Hn={makeEmptyStoreState:na,getNextTreeStateVersion:Gn};class oa{}var Xt={RetentionZone:oa};function ra(e,t){const n=new Set(e);return n.add(t),n}var aa={setByAddingToSet:ra};function*sa(e,t){let n=0;for(const o of e)t(o,n++)&&(yield o)}var Jt=sa;function ia(e,t){return new Proxy(e,{get:(o,r)=>(!(r in o)&&r in t&&(o[r]=t[r]()),o[r]),ownKeys:o=>Object.keys(o)})}var jn=ia;const{getNode:Qe,getNodeMaybe:la,recoilValuesForKeys:_n}=_e,{RetentionZone:mn}=Xt,{setByAddingToSet:ca}=aa,ua=Object.freeze(new Set);class da extends Error{}function fa(e,t,n){if(!F("recoil_memory_managament_2020"))return()=>{};const{nodesRetainedByZone:o}=e.getState().retention;function r(a){let i=o.get(a);i||o.set(a,i=new Set),i.add(t)}if(n instanceof mn)r(n);else if(Array.isArray(n))for(const a of n)r(a);return()=>{if(!F("recoil_memory_managament_2020"))return;const{retention:a}=e.getState();function i(u){const d=a.nodesRetainedByZone.get(u);d==null||d.delete(t),d&&d.size===0&&a.nodesRetainedByZone.delete(u)}if(n instanceof mn)i(n);else if(Array.isArray(n))for(const u of n)i(u)}}function Qt(e,t,n,o){const r=e.getState();if(r.nodeCleanupFunctions.has(n))return;const a=Qe(n),i=fa(e,n,a.retainedBy),u=a.init(e,t,o);r.nodeCleanupFunctions.set(n,()=>{u(),i()})}function ha(e,t,n){Qt(e,e.getState().currentTree,t,n)}function va(e,t){var n;const o=e.getState();(n=o.nodeCleanupFunctions.get(t))===null||n===void 0||n(),o.nodeCleanupFunctions.delete(t)}function pa(e,t,n){return Qt(e,t,n,"get"),Qe(n).get(e,t)}function qn(e,t,n){return Qe(n).peek(e,t)}function _a(e,t,n){var o;const r=la(t);return r==null||(o=r.invalidate)===null||o===void 0||o.call(r,e),{...e,atomValues:e.atomValues.clone().delete(t),nonvalidatedAtoms:e.nonvalidatedAtoms.clone().set(t,n),dirtyAtoms:ca(e.dirtyAtoms,t)}}function ma(e,t,n,o){const r=Qe(n);if(r.set==null)throw new da(`Attempt to set read-only RecoilValue: ${n}`);const a=r.set;return Qt(e,t,n,"set"),a(e,t,o)}function ya(e,t,n){const o=e.getState(),r=e.getGraph(t.version),a=Qe(n).nodeType;return jn({type:a},{loadable:()=>qn(e,t,n),isActive:()=>o.knownAtoms.has(n)||o.knownSelectors.has(n),isSet:()=>a==="selector"?!1:t.atomValues.has(n),isModified:()=>t.dirtyAtoms.has(n),deps:()=>{var i;return _n((i=r.nodeDeps.get(n))!==null&&i!==void 0?i:[])},subscribers:()=>{var i,u;return{nodes:_n(Jt(Zn(e,t,new Set([n])),d=>d!==n)),components:pt((i=(u=o.nodeToComponentSubscriptions.get(n))===null||u===void 0?void 0:u.values())!==null&&i!==void 0?i:[],([d])=>({name:d}))}}})}function Zn(e,t,n){const o=new Set,r=Array.from(n),a=e.getGraph(t.version);for(let u=r.pop();u;u=r.pop()){var i;o.add(u);const d=(i=a.nodeToNodeSubscriptions.get(u))!==null&&i!==void 0?i:ua;for(const f of d)o.has(f)||r.push(f)}return o}var Ne={getNodeLoadable:pa,peekNodeLoadable:qn,setNodeValue:ma,initializeNode:ha,cleanUpNode:va,setUnvalidatedAtomValue_DEPRECATED:_a,peekNodeInfo:ya,getDownstreamNodes:Zn};let Yn=null;function Sa(e){Yn=e}function ga(){var e;(e=Yn)===null||e===void 0||e()}var Xn={setInvalidateMemoizedSnapshot:Sa,invalidateMemoizedSnapshot:ga};const{getDownstreamNodes:Ra,getNodeLoadable:Jn,setNodeValue:ba}=Ne,{getNextComponentID:wa}=_t,{getNode:Ea,getNodeMaybe:Qn}=_e,{DefaultValue:en}=_e,{reactMode:Ta}=Ht,{AbstractRecoilValue:Aa,RecoilState:pc,RecoilValueReadOnly:_c,isRecoilValue:mc}=Te,{invalidateMemoizedSnapshot:Na}=Xn;function La(e,{key:t},n=e.getState().currentTree){var o,r;const a=e.getState();n.version===a.currentTree.version||n.version===((o=a.nextTree)===null||o===void 0?void 0:o.version)||n.version===((r=a.previousTree)===null||r===void 0?void 0:r.version)||ie();const i=Jn(e,n,t);return i.state==="loading"&&i.contents.catch(()=>{}),i}function Ca(e,t){const n=e.clone();return t.forEach((o,r)=>{o.state==="hasValue"&&o.contents instanceof en?n.delete(r):n.set(r,o)}),n}function Va(e,t,{key:n},o){if(typeof o=="function"){const r=Jn(e,t,n);if(r.state==="loading"){const a=`Tried to set atom or selector "${n}" using an updater function while the current state is pending, this is not currently supported.`;throw ie(),M(a)}else if(r.state==="hasError")throw r.contents;return o(r.contents)}else return o}function $a(e,t,n){if(n.type==="set"){const{recoilValue:r,valueOrUpdater:a}=n,i=Va(e,t,r,a),u=ba(e,t,r.key,i);for(const[d,f]of u.entries())Ot(t,d,f)}else if(n.type==="setLoadable"){const{recoilValue:{key:r},loadable:a}=n;Ot(t,r,a)}else if(n.type==="markModified"){const{recoilValue:{key:r}}=n;t.dirtyAtoms.add(r)}else if(n.type==="setUnvalidated"){var o;const{recoilValue:{key:r},unvalidatedValue:a}=n,i=Qn(r);i==null||(o=i.invalidate)===null||o===void 0||o.call(i,t),t.atomValues.delete(r),t.nonvalidatedAtoms.set(r,a),t.dirtyAtoms.add(r)}else ie(`Unknown action ${n.type}`)}function Ot(e,t,n){n.state==="hasValue"&&n.contents instanceof en?e.atomValues.delete(t):e.atomValues.set(t,n),e.dirtyAtoms.add(t),e.nonvalidatedAtoms.delete(t)}function eo(e,t){e.replaceState(n=>{const o=to(n);for(const r of t)$a(e,o,r);return no(e,o),Na(),o})}function mt(e,t){if(je.length){const n=je[je.length-1];let o=n.get(e);o||n.set(e,o=[]),o.push(t)}else eo(e,[t])}const je=[];function Ma(){const e=new Map;return je.push(e),()=>{for(const[n,o]of e)eo(n,o);je.pop()!==e&&ie()}}function to(e){return{...e,atomValues:e.atomValues.clone(),nonvalidatedAtoms:e.nonvalidatedAtoms.clone(),dirtyAtoms:new Set(e.dirtyAtoms)}}function no(e,t){const n=Ra(e,t,t.dirtyAtoms);for(const a of n){var o,r;(o=Qn(a))===null||o===void 0||(r=o.invalidate)===null||r===void 0||r.call(o,t)}}function oo(e,t,n){mt(e,{type:"set",recoilValue:t,valueOrUpdater:n})}function ka(e,t,n){if(n instanceof en)return oo(e,t,n);mt(e,{type:"setLoadable",recoilValue:t,loadable:n})}function Ia(e,t){mt(e,{type:"markModified",recoilValue:t})}function Da(e,t,n){mt(e,{type:"setUnvalidated",recoilValue:t,unvalidatedValue:n})}function Ua(e,{key:t},n,o=null){const r=wa(),a=e.getState();a.nodeToComponentSubscriptions.has(t)||a.nodeToComponentSubscriptions.set(t,new Map),j(a.nodeToComponentSubscriptions.get(t)).set(r,[o??"<not captured>",n]);const i=Ta();if(i.early&&(i.mode==="LEGACY"||i.mode==="MUTABLE_SOURCE")){const u=e.getState().nextTree;u&&u.dirtyAtoms.has(t)&&n(u)}return{release:()=>{const u=e.getState(),d=u.nodeToComponentSubscriptions.get(t);if(d===void 0||!d.has(r)){ie();return}d.delete(r),d.size===0&&u.nodeToComponentSubscriptions.delete(t)}}}function Pa(e,t){var n;const{currentTree:o}=e.getState(),r=Ea(t.key);(n=r.clearCache)===null||n===void 0||n.call(r,e,o)}var ge={AbstractRecoilValue:Aa,getRecoilValueAsLoadable:La,setRecoilValue:oo,setRecoilValueLoadable:ka,markRecoilValueModified:Ia,setUnvalidatedRecoilValue:Da,subscribeToRecoilValue:Ua,applyAtomValueWrites:Ca,batchStart:Ma,writeLoadableToTreeState:Ot,invalidateDownstreams:no,copyTreeState:to,refreshRecoilValue:Pa};function xa(e,t,n){const o=e.entries();let r=o.next();for(;!r.done;){const a=r.value;if(t.call(n,a[1],a[0],e))return!0;r=o.next()}return!1}var Oa=xa;const{cleanUpNode:Ba}=Ne,{deleteNodeConfigIfPossible:za,getNode:ro}=_e,{RetentionZone:ao}=Xt,Fa=12e4,so=new Set;function io(e,t){const n=e.getState(),o=n.currentTree;if(n.nextTree){ie();return}const r=new Set;for(const i of t)if(i instanceof ao)for(const u of Ha(n,i))r.add(u);else r.add(i);const a=Wa(e,r);for(const i of a)Ga(e,o,i)}function Wa(e,t){const n=e.getState(),o=n.currentTree,r=e.getGraph(o.version),a=new Set,i=new Set;return u(t),a;function u(d){const f=new Set,p=Ka(e,o,d,a,i);for(const E of p){var g;if(ro(E).retainedBy==="recoilRoot"){i.add(E);continue}if(((g=n.retention.referenceCounts.get(E))!==null&&g!==void 0?g:0)>0){i.add(E);continue}if(lo(E).some(Q=>n.retention.referenceCounts.get(Q))){i.add(E);continue}const $=r.nodeToNodeSubscriptions.get(E);if($&&Oa($,Q=>i.has(Q))){i.add(E);continue}a.add(E),f.add(E)}const D=new Set;for(const E of f)for(const $ of(L=r.nodeDeps.get(E))!==null&&L!==void 0?L:so){var L;a.has($)||D.add($)}D.size&&u(D)}}function Ka(e,t,n,o,r){const a=e.getGraph(t.version),i=[],u=new Set;for(;n.size>0;)d(j(n.values().next().value));return i;function d(f){if(o.has(f)||r.has(f)){n.delete(f);return}if(u.has(f))return;const p=a.nodeToNodeSubscriptions.get(f);if(p)for(const g of p)d(g);u.add(f),n.delete(f),i.push(f)}}function Ga(e,t,n){if(!F("recoil_memory_managament_2020"))return;Ba(e,n);const o=e.getState();o.knownAtoms.delete(n),o.knownSelectors.delete(n),o.nodeTransactionSubscriptions.delete(n),o.retention.referenceCounts.delete(n);const r=lo(n);for(const d of r){var a;(a=o.retention.nodesRetainedByZone.get(d))===null||a===void 0||a.delete(n)}t.atomValues.delete(n),t.dirtyAtoms.delete(n),t.nonvalidatedAtoms.delete(n);const i=o.graphsByVersion.get(t.version);if(i){const d=i.nodeDeps.get(n);if(d!==void 0){i.nodeDeps.delete(n);for(const f of d){var u;(u=i.nodeToNodeSubscriptions.get(f))===null||u===void 0||u.delete(n)}}i.nodeToNodeSubscriptions.delete(n)}za(n)}function Ha(e,t){var n;return(n=e.retention.nodesRetainedByZone.get(t))!==null&&n!==void 0?n:so}function lo(e){const t=ro(e).retainedBy;return t===void 0||t==="components"||t==="recoilRoot"?[]:t instanceof ao?[t]:t}function ja(e,t){const n=e.getState();n.nextTree?n.retention.retainablesToCheckForRelease.add(t):io(e,new Set([t]))}function qa(e,t,n){var o;if(!F("recoil_memory_managament_2020"))return;const r=e.getState().retention.referenceCounts,a=((o=r.get(t))!==null&&o!==void 0?o:0)+n;a===0?Za(e,t):r.set(t,a)}function Za(e,t){if(!F("recoil_memory_managament_2020"))return;e.getState().retention.referenceCounts.delete(t),ja(e,t)}function Ya(e){if(!F("recoil_memory_managament_2020"))return;const t=e.getState();io(e,t.retention.retainablesToCheckForRelease),t.retention.retainablesToCheckForRelease.clear()}function Xa(e){return e===void 0?"recoilRoot":e}var Pe={SUSPENSE_TIMEOUT_MS:Fa,updateRetainCount:qa,releaseScheduledRetainablesNow:Ya,retainedByOptionWithDefault:Xa};const{unstable_batchedUpdates:Ja}=qo;var Qa={unstable_batchedUpdates:Ja};const{unstable_batchedUpdates:es}=Qa;var ts={unstable_batchedUpdates:es};const{batchStart:ns}=ge,{unstable_batchedUpdates:os}=ts;let rs=os||(e=>e());const as=e=>{rs(()=>{let t=()=>{};try{t=ns(),e()}finally{t()}})};var tn={batchUpdates:as};function*ss(e){for(const t of e)for(const n of t)yield n}var co=ss;const is=typeof Window>"u"||typeof window>"u";var nn={isSSR:is};function ls(e,t){let n,o;return[(...i)=>{const u=t(...i);return n===u||(n=u,o=e(...i)),o},()=>{n=null}]}var cs={memoizeOneWithArgsHashAndInvalidation:ls};const{batchUpdates:Bt}=tn,{initializeNode:us,peekNodeInfo:ds}=Ne,{graph:fs}=Je,{getNextStoreID:hs}=_t,{DEFAULT_VALUE:vs,recoilValues:yn,recoilValuesForKeys:Sn}=_e,{AbstractRecoilValue:ps,getRecoilValueAsLoadable:_s,setRecoilValue:gn,setUnvalidatedRecoilValue:ms}=ge,{updateRetainCount:lt}=Pe,{setInvalidateMemoizedSnapshot:ys}=Xn,{getNextTreeStateVersion:Ss,makeEmptyStoreState:gs}=Hn,{isSSR:Rs}=nn,{memoizeOneWithArgsHashAndInvalidation:bs}=cs;class yt{constructor(t,n){V(this,"_store",void 0),V(this,"_refCount",1),V(this,"getLoadable",o=>(this.checkRefCount_INTERNAL(),_s(this._store,o))),V(this,"getPromise",o=>(this.checkRefCount_INTERNAL(),this.getLoadable(o).toPromise())),V(this,"getNodes_UNSTABLE",o=>{if(this.checkRefCount_INTERNAL(),(o==null?void 0:o.isModified)===!0){if((o==null?void 0:o.isInitialized)===!1)return[];const i=this._store.getState().currentTree;return Sn(i.dirtyAtoms)}const r=this._store.getState().knownAtoms,a=this._store.getState().knownSelectors;return(o==null?void 0:o.isInitialized)==null?yn.values():o.isInitialized===!0?Sn(co([r,a])):Jt(yn.values(),({key:i})=>!r.has(i)&&!a.has(i))}),V(this,"getInfo_UNSTABLE",({key:o})=>(this.checkRefCount_INTERNAL(),ds(this._store,this._store.getState().currentTree,o))),V(this,"map",o=>{this.checkRefCount_INTERNAL();const r=new zt(this,Bt);return o(r),r}),V(this,"asyncMap",async o=>{this.checkRefCount_INTERNAL();const r=new zt(this,Bt);return r.retain(),await o(r),r.autoRelease_INTERNAL(),r}),this._store={storeID:hs(),parentStoreID:n,getState:()=>t,replaceState:o=>{t.currentTree=o(t.currentTree)},getGraph:o=>{const r=t.graphsByVersion;if(r.has(o))return j(r.get(o));const a=fs();return r.set(o,a),a},subscribeToTransactions:()=>({release:()=>{}}),addTransactionMetadata:()=>{throw M("Cannot subscribe to Snapshots")}};for(const o of this._store.getState().knownAtoms)us(this._store,o,"get"),lt(this._store,o,1);this.autoRelease_INTERNAL()}retain(){this._refCount<=0&&ie(),this._refCount++;let t=!1;return()=>{t||(t=!0,this._release())}}autoRelease_INTERNAL(){Rs||window.setTimeout(()=>this._release(),10)}_release(){if(this._refCount--,this._refCount===0){if(this._store.getState().nodeCleanupFunctions.forEach(t=>t()),this._store.getState().nodeCleanupFunctions.clear(),!F("recoil_memory_managament_2020"))return}else this._refCount<0}isRetained(){return this._refCount>0}checkRefCount_INTERNAL(){F("recoil_memory_managament_2020")&&this._refCount<=0}getStore_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store}getID(){return this.checkRefCount_INTERNAL(),this._store.getState().currentTree.stateID}getStoreID(){return this.checkRefCount_INTERNAL(),this._store.storeID}}function uo(e,t,n=!1){const o=e.getState(),r=n?Ss():t.version;return{currentTree:{version:n?r:t.version,stateID:n?r:t.stateID,transactionMetadata:{...t.transactionMetadata},dirtyAtoms:new Set(t.dirtyAtoms),atomValues:t.atomValues.clone(),nonvalidatedAtoms:t.nonvalidatedAtoms.clone()},commitDepth:0,nextTree:null,previousTree:null,knownAtoms:new Set(o.knownAtoms),knownSelectors:new Set(o.knownSelectors),transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:new Map().set(r,e.getGraph(t.version)),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map(pt(o.nodeCleanupFunctions.entries(),([a])=>[a,()=>{}]))}}function ws(e){const t=new yt(gs());return e!=null?t.map(e):t}const[Rn,fo]=bs((e,t)=>{var n;const o=e.getState(),r=t==="latest"?(n=o.nextTree)!==null&&n!==void 0?n:o.currentTree:j(o.previousTree);return new yt(uo(e,r),e.storeID)},(e,t)=>{var n,o;return String(t)+String(e.storeID)+String((n=e.getState().nextTree)===null||n===void 0?void 0:n.version)+String(e.getState().currentTree.version)+String((o=e.getState().previousTree)===null||o===void 0?void 0:o.version)});ys(fo);function Es(e,t="latest"){const n=Rn(e,t);return n.isRetained()?n:(fo(),Rn(e,t))}class zt extends yt{constructor(t,n){super(uo(t.getStore_INTERNAL(),t.getStore_INTERNAL().getState().currentTree,!0),t.getStoreID()),V(this,"_batch",void 0),V(this,"set",(o,r)=>{this.checkRefCount_INTERNAL();const a=this.getStore_INTERNAL();this._batch(()=>{lt(a,o.key,1),gn(this.getStore_INTERNAL(),o,r)})}),V(this,"reset",o=>{this.checkRefCount_INTERNAL();const r=this.getStore_INTERNAL();this._batch(()=>{lt(r,o.key,1),gn(this.getStore_INTERNAL(),o,vs)})}),V(this,"setUnvalidatedAtomValues_DEPRECATED",o=>{this.checkRefCount_INTERNAL();const r=this.getStore_INTERNAL();Bt(()=>{for(const[a,i]of o.entries())lt(r,a,1),ms(r,new ps(a),i)})}),this._batch=n}}var St={Snapshot:yt,MutableSnapshot:zt,freshSnapshot:ws,cloneSnapshot:Es},Ts=St.Snapshot,As=St.MutableSnapshot,Ns=St.freshSnapshot,Ls=St.cloneSnapshot,gt=Object.freeze({__proto__:null,Snapshot:Ts,MutableSnapshot:As,freshSnapshot:Ns,cloneSnapshot:Ls});function Cs(...e){const t=new Set;for(const n of e)for(const o of n)t.add(o);return t}var Vs=Cs;const{useRef:$s}=Z;function Ms(e){const t=$s(e);return t.current===e&&typeof e=="function"&&(t.current=e()),t}var bn=Ms;const{getNextTreeStateVersion:ks,makeEmptyStoreState:ho}=Hn,{cleanUpNode:Is,getDownstreamNodes:Ds,initializeNode:Us,setNodeValue:Ps,setUnvalidatedAtomValue_DEPRECATED:xs}=Ne,{graph:Os}=Je,{cloneGraph:Bs}=Je,{getNextStoreID:vo}=_t,{createMutableSource:It,reactMode:po}=Ht,{applyAtomValueWrites:zs}=ge,{releaseScheduledRetainablesNow:_o}=Pe,{freshSnapshot:Fs}=gt,{useCallback:Ws,useContext:mo,useEffect:Ft,useMemo:Ks,useRef:Gs,useState:Hs}=Z;function ze(){throw M("This component must be used inside a <RecoilRoot> component.")}const yo=Object.freeze({storeID:vo(),getState:ze,replaceState:ze,getGraph:ze,subscribeToTransactions:ze,addTransactionMetadata:ze});let Wt=!1;function wn(e){if(Wt)throw M("An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.");const t=e.getState();if(t.nextTree===null){F("recoil_memory_managament_2020")&&F("recoil_release_on_cascading_update_killswitch_2021")&&t.commitDepth>0&&_o(e);const n=t.currentTree.version,o=ks();t.nextTree={...t.currentTree,version:o,stateID:o,dirtyAtoms:new Set,transactionMetadata:{}},t.graphsByVersion.set(o,Bs(j(t.graphsByVersion.get(n))))}}const So=Z.createContext({current:yo}),on=()=>mo(So),go=Z.createContext(null);function js(){const e=mo(go);return e==null&&Fn(),e}function Ro(e,t,n){const o=Ds(e,n,n.dirtyAtoms);for(const r of o){const a=t.nodeToComponentSubscriptions.get(r);if(a)for(const[i,[u,d]]of a)d(n)}}function qs(e){const t=e.getState(),n=t.currentTree,o=n.dirtyAtoms;if(o.size){for(const[r,a]of t.nodeTransactionSubscriptions)if(o.has(r))for(const[i,u]of a)u(e);for(const[r,a]of t.transactionSubscriptions)a(e);(!po().early||t.suspendedComponentResolvers.size>0)&&(Ro(e,t,n),t.suspendedComponentResolvers.forEach(r=>r()),t.suspendedComponentResolvers.clear())}t.queuedComponentCallbacks_DEPRECATED.forEach(r=>r(n)),t.queuedComponentCallbacks_DEPRECATED.splice(0,t.queuedComponentCallbacks_DEPRECATED.length)}function Zs(e){const t=e.getState();t.commitDepth++;try{const{nextTree:n}=t;if(n==null)return;t.previousTree=t.currentTree,t.currentTree=n,t.nextTree=null,qs(e),t.previousTree!=null?t.graphsByVersion.delete(t.previousTree.version):ie("Ended batch with no previous state, which is unexpected","recoil"),t.previousTree=null,F("recoil_memory_managament_2020")&&n==null&&_o(e)}finally{t.commitDepth--}}function Ys({setNotifyBatcherOfChange:e}){const t=on(),[,n]=Hs([]);return e(()=>n({})),Ft(()=>(e(()=>n({})),()=>{e(()=>{})}),[e]),Ft(()=>{Ur.enqueueExecution("Batcher",()=>{Zs(t.current)})}),null}function Xs(e,t){const n=ho();return t({set:(o,r)=>{const a=n.currentTree,i=Ps(e,a,o.key,r),u=new Set(i.keys()),d=a.nonvalidatedAtoms.clone();for(const f of u)d.delete(f);n.currentTree={...a,dirtyAtoms:Vs(a.dirtyAtoms,u),atomValues:zs(a.atomValues,i),nonvalidatedAtoms:d}},setUnvalidatedAtomValues:o=>{o.forEach((r,a)=>{n.currentTree=xs(n.currentTree,a,r)})}}),n}function Js(e){const t=Fs(e),n=t.getStore_INTERNAL().getState();return t.retain(),n.nodeCleanupFunctions.forEach(o=>o()),n.nodeCleanupFunctions.clear(),n}let En=0;function Qs({initializeState_DEPRECATED:e,initializeState:t,store_INTERNAL:n,children:o}){let r;const a=L=>{const E=r.current.graphsByVersion;if(E.has(L))return j(E.get(L));const $=Os();return E.set(L,$),$},i=(L,E)=>{if(E==null){const{transactionSubscriptions:$}=g.current.getState(),Q=En++;return $.set(Q,L),{release:()=>{$.delete(Q)}}}else{const{nodeTransactionSubscriptions:$}=g.current.getState();$.has(E)||$.set(E,new Map);const Q=En++;return j($.get(E)).set(Q,L),{release:()=>{const te=$.get(E);te&&(te.delete(Q),te.size===0&&$.delete(E))}}}},u=L=>{wn(g.current);for(const E of Object.keys(L))j(g.current.getState().nextTree).transactionMetadata[E]=L[E]},d=L=>{wn(g.current);const E=j(r.current.nextTree);let $;try{Wt=!0,$=L(E)}finally{Wt=!1}$!==E&&(r.current.nextTree=$,po().early&&Ro(g.current,r.current,$),j(f.current)())},f=Gs(null),p=Ws(L=>{f.current=L},[f]),g=bn(()=>n??{storeID:vo(),getState:()=>r.current,replaceState:d,getGraph:a,subscribeToTransactions:i,addTransactionMetadata:u});n!=null&&(g.current=n),r=bn(()=>e!=null?Xs(g.current,e):t!=null?Js(t):ho());const D=Ks(()=>It==null?void 0:It(r,()=>r.current.currentTree.version),[r]);return Ft(()=>{const L=g.current;for(const E of new Set(L.getState().knownAtoms))Us(L,E,"get");return()=>{for(const E of L.getState().knownAtoms)Is(L,E)}},[g]),Z.createElement(So.Provider,{value:g},Z.createElement(go.Provider,{value:D},Z.createElement(Ys,{setNotifyBatcherOfChange:p}),o))}function ei(e){const{override:t,...n}=e,o=on();return t===!1&&o.current!==yo?e.children:Z.createElement(Qs,n)}var rn={RecoilRoot:ei,useStoreRef:on,useRecoilMutableSource:js};function ti(e,t){if(e===t)return!0;if(e.length!==t.length)return!1;for(let n=0,o=e.length;n<o;n++)if(e[n]!==t[n])return!1;return!0}var ni=ti;const{useEffect:oi,useRef:ri}=Z;function ai(e){const t=ri();return oi(()=>{t.current=e}),t.current}var si=ai;const{useStoreRef:ii}=rn,{SUSPENSE_TIMEOUT_MS:li}=Pe,{updateRetainCount:Fe}=Pe,{RetentionZone:ci}=Xt,{useEffect:ui,useRef:di}=Z,{isSSR:Tn}=nn;function fi(e){if(F("recoil_memory_managament_2020"))return hi(e)}function hi(e){const n=(Array.isArray(e)?e:[e]).map(i=>i instanceof ci?i:i.key),o=ii();ui(()=>{if(!F("recoil_memory_managament_2020"))return;const i=o.current;if(r.current&&!Tn)window.clearTimeout(r.current),r.current=null;else for(const u of n)Fe(i,u,1);return()=>{for(const u of n)Fe(i,u,-1)}},[o,...n]);const r=di(),a=si(n);if(!Tn&&(a===void 0||!ni(a,n))){const i=o.current;for(const u of n)Fe(i,u,1);if(a)for(const u of a)Fe(i,u,-1);r.current&&window.clearTimeout(r.current),r.current=window.setTimeout(()=>{r.current=null;for(const u of n)Fe(i,u,-1)},li)}}var vi=fi;function pi(){return"<component name not available>"}var Rt=pi;const{currentRendererSupportsUseSyncExternalStore:_i,reactMode:et,useMutableSource:mi,useSyncExternalStore:yi}=Ht,{useRecoilMutableSource:Si,useStoreRef:xe}=rn,{isRecoilValue:yc}=Te,{getRecoilValueAsLoadable:bt,setRecoilValue:gi,subscribeToRecoilValue:wt}=ge,{useCallback:pe,useEffect:ut,useMemo:Ri,useRef:bo,useState:wo}=Z,{isSSR:bi}=nn;function wi(e,t,n){if(e.state==="hasValue")return e.contents;throw e.state==="loading"?new Promise(r=>{const a=n.current.getState().suspendedComponentResolvers;a.add(r),bi&&K(e.contents)&&e.contents.finally(()=>{a.delete(r)})}):e.state==="hasError"?e.contents:M(`Invalid value of loadable atom "${t.key}"`)}function Ei(e){const t=xe(),n=Rt(),o=pe(()=>{var u;const d=t.current,f=d.getState(),p=et().early&&(u=f.nextTree)!==null&&u!==void 0?u:f.currentTree;return{loadable:bt(d,e,p),key:e.key}},[t,e]),r=pe(u=>{let d;return()=>{var f,p;const g=u();return(f=d)!==null&&f!==void 0&&f.loadable.is(g.loadable)&&((p=d)===null||p===void 0?void 0:p.key)===g.key?d:(d=g,g)}},[]),a=Ri(()=>r(o),[o,r]),i=pe(u=>{const d=t.current;return wt(d,e,u,n).release},[t,e,n]);return yi(i,a,a).loadable}function Ti(e){const t=xe(),n=pe(()=>{var f;const p=t.current,g=p.getState(),D=et().early&&(f=g.nextTree)!==null&&f!==void 0?f:g.currentTree;return bt(p,e,D)},[t,e]),o=pe(()=>n(),[n]),r=Rt(),a=pe((f,p)=>{const g=t.current;return wt(g,e,()=>{if(!F("recoil_suppress_rerender_in_callback"))return p();const L=n();d.current.is(L)||p(),d.current=L},r).release},[t,e,r,n]),i=Si();if(i==null)throw M("Recoil hooks must be used in components contained within a <RecoilRoot> component.");const u=mi(i,o,a),d=bo(u);return ut(()=>{d.current=u}),u}function An(e){const t=xe(),n=Rt(),o=pe(()=>{var d;const f=t.current,p=f.getState(),g=et().early&&(d=p.nextTree)!==null&&d!==void 0?d:p.currentTree;return bt(f,e,g)},[t,e]),r=pe(()=>({loadable:o(),key:e.key}),[o,e.key]),a=pe(d=>{const f=r();return d.loadable.is(f.loadable)&&d.key===f.key?d:f},[r]);ut(()=>{const d=wt(t.current,e,f=>{u(a)},n);return u(a),d.release},[n,e,t,a]);const[i,u]=wo(r);return i.key!==e.key?r().loadable:i.loadable}function Ai(e){const t=xe(),[,n]=wo([]),o=Rt(),r=pe(()=>{var u;const d=t.current,f=d.getState(),p=et().early&&(u=f.nextTree)!==null&&u!==void 0?u:f.currentTree;return bt(d,e,p)},[t,e]),a=r(),i=bo(a);return ut(()=>{i.current=a}),ut(()=>{const u=t.current,d=u.getState(),f=wt(u,e,g=>{var D;if(!F("recoil_suppress_rerender_in_callback"))return n([]);const L=r();(D=i.current)!==null&&D!==void 0&&D.is(L)||n(L),i.current=L},o);if(d.nextTree)u.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{i.current=null,n([])});else{var p;if(!F("recoil_suppress_rerender_in_callback"))return n([]);const g=r();(p=i.current)!==null&&p!==void 0&&p.is(g)||n(g),i.current=g}return f.release},[o,r,e,t]),a}function Ni(e){return F("recoil_memory_managament_2020")&&vi(e),{TRANSITION_SUPPORT:An,SYNC_EXTERNAL_STORE:_i()?Ei:An,MUTABLE_SOURCE:Ti,LEGACY:Ai}[et().mode](e)}function Li(e){const t=xe(),n=Ni(e);return wi(n,e,t)}function Eo(e){const t=xe();return pe(n=>{gi(t.current,e,n)},[t,e])}function Ci(e){return[Li(e),Eo(e)]}var Vi={useRecoilState:Ci,useSetRecoilState:Eo};const{batchUpdates:$i}=tn,{DEFAULT_VALUE:Mi,getNode:ki}=_e,{AbstractRecoilValue:Ii,setRecoilValueLoadable:Di}=ge,{cloneSnapshot:Sc}=gt,{useCallback:gc,useEffect:Rc,useRef:bc,useState:wc}=Z;function Ui(e,t){var n;const o=e.getState(),r=(n=o.nextTree)!==null&&n!==void 0?n:o.currentTree,a=t.getStore_INTERNAL().getState().currentTree;$i(()=>{const i=new Set;for(const f of[r.atomValues.keys(),a.atomValues.keys()])for(const p of f){var u,d;((u=r.atomValues.get(p))===null||u===void 0?void 0:u.contents)!==((d=a.atomValues.get(p))===null||d===void 0?void 0:d.contents)&&ki(p).shouldRestoreFromSnapshots&&i.add(p)}i.forEach(f=>{Di(e,new Ii(f),a.atomValues.has(f)?j(a.atomValues.get(f)):Mi)}),e.replaceState(f=>({...f,stateID:t.getID()}))})}var Pi={gotoSnapshot:Ui};const{useMemo:Ec}=Z,{loadableWithValue:xi}=Ye,{initializeNode:Oi}=Ne,{DEFAULT_VALUE:Bi,getNode:zi}=_e,{copyTreeState:Fi,getRecoilValueAsLoadable:Wi,invalidateDownstreams:Ki,writeLoadableToTreeState:Gi}=ge;function Nn(e){return zi(e.key).nodeType==="atom"}class Hi{constructor(t,n){V(this,"_store",void 0),V(this,"_treeState",void 0),V(this,"_changes",void 0),V(this,"get",o=>{if(this._changes.has(o.key))return this._changes.get(o.key);if(!Nn(o))throw M("Reading selectors within atomicUpdate is not supported");const r=Wi(this._store,o,this._treeState);if(r.state==="hasValue")return r.contents;throw r.state==="hasError"?r.contents:M(`Expected Recoil atom ${o.key} to have a value, but it is in a loading state.`)}),V(this,"set",(o,r)=>{if(!Nn(o))throw M("Setting selectors within atomicUpdate is not supported");if(typeof r=="function"){const a=this.get(o);this._changes.set(o.key,r(a))}else Oi(this._store,o.key,"set"),this._changes.set(o.key,r)}),V(this,"reset",o=>{this.set(o,Bi)}),this._store=t,this._treeState=n,this._changes=new Map}newTreeState_INTERNAL(){if(this._changes.size===0)return this._treeState;const t=Fi(this._treeState);for(const[n,o]of this._changes)Gi(t,n,xi(o));return Ki(this._store,t),t}}function ji(e){return t=>{e.replaceState(n=>{const o=new Hi(e,n);return t(o),o.newTreeState_INTERNAL()})}}var qi={atomicUpdater:ji},Zi=qi.atomicUpdater,To=Object.freeze({__proto__:null,atomicUpdater:Zi});function Yi(e,t){if(!e)throw new Error(t)}var Xi=Yi,He=Xi;const{atomicUpdater:Ji}=To,{batchUpdates:Qi}=tn,{DEFAULT_VALUE:el}=_e,{refreshRecoilValue:tl,setRecoilValue:Ln}=ge,{cloneSnapshot:nl}=gt,{gotoSnapshot:ol}=Pi,{useCallback:Tc}=Z;class Ao{}const rl=new Ao;function al(e,t,n,o){let r=rl,a;if(Qi(()=>{const u="useRecoilCallback() expects a function that returns a function: it accepts a function of the type (RecoilInterface) => (Args) => ReturnType and returns a callback function (Args) => ReturnType, where RecoilInterface is an object {snapshot, set, ...} and Args and ReturnType are the argument and return types of the callback you want to create.  Please see the docs at recoiljs.org for details.";if(typeof t!="function")throw M(u);const d=jn({...o??{},set:(p,g)=>Ln(e,p,g),reset:p=>Ln(e,p,el),refresh:p=>tl(e,p),gotoSnapshot:p=>ol(e,p),transact_UNSTABLE:p=>Ji(e)(p)},{snapshot:()=>{const p=nl(e);return a=p.retain(),p}}),f=t(d);if(typeof f!="function")throw M(u);r=f(...n)}),r instanceof Ao&&He(!1),K(r))r=r.finally(()=>{var u;(u=a)===null||u===void 0||u()});else{var i;(i=a)===null||i===void 0||i()}return r}var sl={recoilCallback:al};const{useCallback:Ac}=Z,{atomicUpdater:Nc}=To,{useMemo:Lc}=Z;class il{constructor(t){V(this,"value",void 0),this.value=t}}var ll={WrappedValue:il},cl=ll.WrappedValue,No=Object.freeze({__proto__:null,WrappedValue:cl});class Cn extends Error{}class ul{constructor(t){var n,o,r;V(this,"_name",void 0),V(this,"_numLeafs",void 0),V(this,"_root",void 0),V(this,"_onHit",void 0),V(this,"_onSet",void 0),V(this,"_mapNodeValue",void 0),this._name=t==null?void 0:t.name,this._numLeafs=0,this._root=null,this._onHit=(n=t==null?void 0:t.onHit)!==null&&n!==void 0?n:()=>{},this._onSet=(o=t==null?void 0:t.onSet)!==null&&o!==void 0?o:()=>{},this._mapNodeValue=(r=t==null?void 0:t.mapNodeValue)!==null&&r!==void 0?r:a=>a}size(){return this._numLeafs}root(){return this._root}get(t,n){var o;return(o=this.getLeafNode(t,n))===null||o===void 0?void 0:o.value}getLeafNode(t,n){if(this._root==null)return;let o=this._root;for(;o;){if(n==null||n.onNodeVisit(o),o.type==="leaf")return this._onHit(o),o;const r=this._mapNodeValue(t(o.nodeKey));o=o.branches.get(r)}}set(t,n,o){const r=()=>{var a,i,u,d;let f,p;for(const[Q,te]of t){var g,D,L;const w=this._root;if((w==null?void 0:w.type)==="leaf")throw this.invalidCacheError();const U=f;if(f=U?U.branches.get(p):w,f=(g=f)!==null&&g!==void 0?g:{type:"branch",nodeKey:Q,parent:U,branches:new Map,branchKey:p},f.type!=="branch"||f.nodeKey!==Q)throw this.invalidCacheError();U==null||U.branches.set(p,f),o==null||(D=o.onNodeVisit)===null||D===void 0||D.call(o,f),p=this._mapNodeValue(te),this._root=(L=this._root)!==null&&L!==void 0?L:f}const E=f?(a=f)===null||a===void 0?void 0:a.branches.get(p):this._root;if(E!=null&&(E.type!=="leaf"||E.branchKey!==p))throw this.invalidCacheError();const $={type:"leaf",value:n,parent:f,branchKey:p};(i=f)===null||i===void 0||i.branches.set(p,$),this._root=(u=this._root)!==null&&u!==void 0?u:$,this._numLeafs++,this._onSet($),o==null||(d=o.onNodeVisit)===null||d===void 0||d.call(o,$)};try{r()}catch(a){if(a instanceof Cn)this.clear(),r();else throw a}}delete(t){const n=this.root();if(!n)return!1;if(t===n)return this._root=null,this._numLeafs=0,!0;let o=t.parent,r=t.branchKey;for(;o;){var a;if(o.branches.delete(r),o===n)return o.branches.size===0?(this._root=null,this._numLeafs=0):this._numLeafs--,!0;if(o.branches.size>0)break;r=(a=o)===null||a===void 0?void 0:a.branchKey,o=o.parent}for(;o!==n;o=o.parent)if(o==null)return!1;return this._numLeafs--,!0}clear(){this._numLeafs=0,this._root=null}invalidCacheError(){throw ie("Invalid cache values.  This happens when selectors do not return consistent values for the same input dependency values.  That may also be caused when using Fast Refresh to change a selector implementation.  Resetting cache."+(this._name!=null?` - ${this._name}`:"")),new Cn}}var dl={TreeCache:ul},fl=dl.TreeCache,Lo=Object.freeze({__proto__:null,TreeCache:fl});class hl{constructor(t){var n;V(this,"_maxSize",void 0),V(this,"_size",void 0),V(this,"_head",void 0),V(this,"_tail",void 0),V(this,"_map",void 0),V(this,"_keyMapper",void 0),this._maxSize=t.maxSize,this._size=0,this._head=null,this._tail=null,this._map=new Map,this._keyMapper=(n=t.mapKey)!==null&&n!==void 0?n:o=>o}head(){return this._head}tail(){return this._tail}size(){return this._size}maxSize(){return this._maxSize}has(t){return this._map.has(this._keyMapper(t))}get(t){const n=this._keyMapper(t),o=this._map.get(n);if(o)return this.set(t,o.value),o.value}set(t,n){const o=this._keyMapper(t);this._map.get(o)&&this.delete(t);const a=this.head(),i={key:t,right:a,left:null,value:n};a?a.left=i:this._tail=i,this._map.set(o,i),this._head=i,this._size++,this._maybeDeleteLRU()}_maybeDeleteLRU(){this.size()>this.maxSize()&&this.deleteLru()}deleteLru(){const t=this.tail();t&&this.delete(t.key)}delete(t){const n=this._keyMapper(t);if(!this._size||!this._map.has(n))return;const o=j(this._map.get(n)),r=o.right,a=o.left;r&&(r.left=o.left),a&&(a.right=o.right),o===this.head()&&(this._head=r),o===this.tail()&&(this._tail=a),this._map.delete(n),this._size--}clear(){this._size=0,this._head=null,this._tail=null,this._map=new Map}}var vl={LRUCache:hl},pl=vl.LRUCache,Co=Object.freeze({__proto__:null,LRUCache:pl});const{LRUCache:_l}=Co,{TreeCache:ml}=Lo;function yl({name:e,maxSize:t,mapNodeValue:n=o=>o}){const o=new _l({maxSize:t}),r=new ml({name:e,mapNodeValue:n,onHit:a=>{o.set(a,!0)},onSet:a=>{const i=o.tail();o.set(a,!0),i&&r.size()>t&&r.delete(i.key)}});return r}var Vn=yl;function ve(e,t,n){if(typeof e=="string"&&!e.includes('"')&&!e.includes("\\"))return`"${e}"`;switch(typeof e){case"undefined":return"";case"boolean":return e?"true":"false";case"number":case"symbol":return String(e);case"string":return JSON.stringify(e);case"function":if((t==null?void 0:t.allowFunctions)!==!0)throw M("Attempt to serialize function in a Recoil cache key");return`__FUNCTION(${e.name})__`}if(e===null)return"null";if(typeof e!="object"){var o;return(o=JSON.stringify(e))!==null&&o!==void 0?o:""}if(K(e))return"__PROMISE__";if(Array.isArray(e))return`[${e.map((r,a)=>ve(r,t,a.toString()))}]`;if(typeof e.toJSON=="function")return ve(e.toJSON(n),t,n);if(e instanceof Map){const r={};for(const[a,i]of e)r[typeof a=="string"?a:ve(a,t)]=i;return ve(r,t,n)}return e instanceof Set?ve(Array.from(e).sort((r,a)=>ve(r,t).localeCompare(ve(a,t))),t,n):Symbol!==void 0&&e[Symbol.iterator]!=null&&typeof e[Symbol.iterator]=="function"?ve(Array.from(e),t,n):`{${Object.keys(e).filter(r=>e[r]!==void 0).sort().map(r=>`${ve(r,t)}:${ve(e[r],t,r)}`).join(",")}}`}function Sl(e,t={allowFunctions:!1}){return ve(e,t)}var an=Sl;const{TreeCache:gl}=Lo,ot={equality:"reference",eviction:"keep-all",maxSize:1/0};function Rl({equality:e=ot.equality,eviction:t=ot.eviction,maxSize:n=ot.maxSize}=ot,o){const r=bl(e);return wl(t,n,r,o)}function bl(e){switch(e){case"reference":return t=>t;case"value":return t=>an(t)}throw M(`Unrecognized equality policy ${e}`)}function wl(e,t,n,o){switch(e){case"keep-all":return new gl({name:o,mapNodeValue:n});case"lru":return Vn({name:o,maxSize:j(t),mapNodeValue:n});case"most-recent":return Vn({name:o,maxSize:1,mapNodeValue:n})}throw M(`Unrecognized eviction policy ${e}`)}var El=Rl;const{isLoadable:Tl,loadableWithError:rt,loadableWithPromise:Al,loadableWithValue:Dt}=Ye,{WrappedValue:Vo}=No,{getNodeLoadable:at,peekNodeLoadable:Nl,setNodeValue:Ll}=Ne,{saveDepsToStore:Cl}=Je,{DEFAULT_VALUE:Vl,getConfigDeletionHandler:$l,getNode:Ml,registerNode:$n}=_e,{isRecoilValue:kl}=Te,{markRecoilValueModified:Mn}=ge,{retainedByOptionWithDefault:Il}=Pe,{recoilCallback:Dl}=sl;class $o{}const We=new $o,Ke=[],st=new Map,Ul=(()=>{let e=0;return()=>e++})();function Mo(e){let t=null;const{key:n,get:o,cachePolicy_UNSTABLE:r}=e,a=e.set!=null?e.set:void 0,i=new Set,u=El(r??{equality:"reference",eviction:"keep-all"},n),d=Il(e.retainedBy_UNSTABLE),f=new Map;let p=0;function g(){return!F("recoil_memory_managament_2020")||p>0}function D(c){return c.getState().knownSelectors.add(n),p++,()=>{p--}}function L(){return $l(n)!==void 0&&!g()}function E(c,v,_,C,R){de(v,C,R),$(c,_)}function $(c,v){le(c,v)&&X(c),te(v,!0)}function Q(c,v){le(c,v)&&(j(J(c)).stateVersions.clear(),te(v,!1))}function te(c,v){const _=st.get(c);if(_!=null){for(const C of _)Mn(C,j(t));v&&st.delete(c)}}function w(c,v){let _=st.get(v);_==null&&st.set(v,_=new Set),_.add(c)}function U(c,v,_,C,R,k){return v.then(b=>{if(!g())throw X(c),We;const x=Dt(b);return E(c,_,R,x,C),b}).catch(b=>{if(!g())throw X(c),We;if(K(b))return Y(c,b,_,C,R,k);const x=rt(b);throw E(c,_,R,x,C),b})}function Y(c,v,_,C,R,k){return v.then(b=>{if(!g())throw X(c),We;k.loadingDepKey!=null&&k.loadingDepPromise===v?_.atomValues.set(k.loadingDepKey,Dt(b)):c.getState().knownSelectors.forEach(O=>{_.atomValues.delete(O)});const x=q(c,_);if(x&&x.state!=="loading"){if((le(c,R)||J(c)==null)&&$(c,R),x.state==="hasValue")return x.contents;throw x.contents}if(!le(c,R)){const O=ye(c,_);if(O!=null)return O.loadingLoadable.contents}const[W,ee]=G(c,_,R);if(W.state!=="loading"&&E(c,_,R,W,ee),W.state==="hasError")throw W.contents;return W.contents}).catch(b=>{if(b instanceof $o)throw We;if(!g())throw X(c),We;const x=rt(b);throw E(c,_,R,x,C),b})}function z(c,v,_,C){var R,k,b,x;if(le(c,C)||v.version===((R=c.getState())===null||R===void 0||(k=R.currentTree)===null||k===void 0?void 0:k.version)||v.version===((b=c.getState())===null||b===void 0||(x=b.nextTree)===null||x===void 0?void 0:x.version)){var W,ee,O;Cl(n,_,c,(W=(ee=c.getState())===null||ee===void 0||(O=ee.nextTree)===null||O===void 0?void 0:O.version)!==null&&W!==void 0?W:c.getState().currentTree.version)}for(const ne of _)i.add(ne)}function G(c,v,_){let C=!0,R=!0;const k=()=>{R=!1};let b,x=!1,W;const ee={loadingDepKey:null,loadingDepPromise:null},O=new Map;function ne({key:ce}){const ae=at(c,v,ce);switch(O.set(ce,ae),C||(z(c,v,new Set(O.keys()),_),Q(c,_)),ae.state){case"hasValue":return ae.contents;case"hasError":throw ae.contents;case"loading":throw ee.loadingDepKey=ce,ee.loadingDepPromise=ae.contents,ae.contents}throw M("Invalid Loadable state")}const me=ce=>(...ae)=>{if(R)throw M("Callbacks from getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can work with Recoil state without a subscription.");return t==null&&He(!1),Dl(c,ce,ae,{node:t})};try{b=o({get:ne,getCallback:me}),b=kl(b)?ne(b):b,Tl(b)&&(b.state==="hasError"&&(x=!0),b=b.contents),K(b)?b=U(c,b,v,O,_,ee).finally(k):k(),b=b instanceof Vo?b.value:b}catch(ce){b=ce,K(b)?b=Y(c,b,v,O,_,ee).finally(k):(x=!0,k())}return x?W=rt(b):K(b)?W=Al(b):W=Dt(b),C=!1,Ce(c,_,O),z(c,v,new Set(O.keys()),_),[W,O]}function q(c,v){let _=v.atomValues.get(n);if(_!=null)return _;const C=new Set;try{_=u.get(k=>(typeof k!="string"&&He(!1),at(c,v,k).contents),{onNodeVisit:k=>{k.type==="branch"&&k.nodeKey!==n&&C.add(k.nodeKey)}})}catch(k){throw M(`Problem with cache lookup for selector "${n}": ${k.message}`)}if(_){var R;v.atomValues.set(n,_),z(c,v,C,(R=J(c))===null||R===void 0?void 0:R.executionID)}return _}function re(c,v){const _=q(c,v);if(_!=null)return X(c),_;const C=ye(c,v);if(C!=null){var R;return((R=C.loadingLoadable)===null||R===void 0?void 0:R.state)==="loading"&&w(c,C.executionID),C.loadingLoadable}const k=Ul(),[b,x]=G(c,v,k);return b.state==="loading"?(ue(c,k,b,x,v),w(c,k)):(X(c),de(v,b,x)),b}function ye(c,v){const _=co([f.has(c)?[j(f.get(c))]:[],pt(Jt(f,([R])=>R!==c),([,R])=>R)]);function C(R){for(const[k,b]of R)if(!at(c,v,k).is(b))return!0;return!1}for(const R of _){if(R.stateVersions.get(v.version)||!C(R.depValuesDiscoveredSoFarDuringAsyncWork))return R.stateVersions.set(v.version,!0),R;R.stateVersions.set(v.version,!1)}}function J(c){return f.get(c)}function ue(c,v,_,C,R){f.set(c,{depValuesDiscoveredSoFarDuringAsyncWork:C,executionID:v,loadingLoadable:_,stateVersions:new Map([[R.version,!0]])})}function Ce(c,v,_){if(le(c,v)){const C=J(c);C!=null&&(C.depValuesDiscoveredSoFarDuringAsyncWork=_)}}function X(c){f.delete(c)}function le(c,v){var _;return v===((_=J(c))===null||_===void 0?void 0:_.executionID)}function be(c){return Array.from(c.entries()).map(([v,_])=>[v,_.contents])}function de(c,v,_){c.atomValues.set(n,v);try{u.set(be(_),v)}catch(C){throw M(`Problem with setting cache for selector "${n}": ${C.message}`)}}function Se(c){if(Ke.includes(n)){const v=`Recoil selector has circular dependencies: ${Ke.slice(Ke.indexOf(n)).join(" → ")}`;return rt(M(v))}Ke.push(n);try{return c()}finally{Ke.pop()}}function Ve(c,v){const _=v.atomValues.get(n);return _??u.get(C=>{var R;return typeof C!="string"&&He(!1),(R=Nl(c,v,C))===null||R===void 0?void 0:R.contents})}function $e(c,v){return Se(()=>re(c,v))}function P(c){c.atomValues.delete(n)}function B(c,v){t==null&&He(!1);for(const C of i){var _;const R=Ml(C);(_=R.clearCache)===null||_===void 0||_.call(R,c,v)}i.clear(),P(v),u.clear(),Mn(c,t)}return a!=null?t=$n({key:n,nodeType:"selector",peek:Ve,get:$e,set:(v,_,C)=>{let R=!1;const k=new Map;function b({key:O}){if(R)throw M("Recoil: Async selector sets are not currently supported.");const ne=at(v,_,O);if(ne.state==="hasValue")return ne.contents;if(ne.state==="loading"){const me=`Getting value of asynchronous atom or selector "${O}" in a pending state while setting selector "${n}" is not yet supported.`;throw ie(),M(me)}else throw ne.contents}function x(O,ne){if(R){const ae="Recoil: Async selector sets are not currently supported.";throw ie(),M(ae)}const me=typeof ne=="function"?ne(b(O)):ne;Ll(v,_,O.key,me).forEach((ae,tt)=>k.set(tt,ae))}function W(O){x(O,Vl)}const ee=a({set:x,get:b,reset:W},C);if(ee!==void 0)throw K(ee)?M("Recoil: Async selector sets are not currently supported."):M("Recoil: selector set should be a void function.");return R=!0,k},init:D,invalidate:P,clearCache:B,shouldDeleteConfigOnRelease:L,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:d}):t=$n({key:n,nodeType:"selector",peek:Ve,get:$e,init:D,invalidate:P,clearCache:B,shouldDeleteConfigOnRelease:L,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:d})}Mo.value=e=>new Vo(e);var qe=Mo;const{isLoadable:Pl,loadableWithError:Ut,loadableWithPromise:Pt,loadableWithValue:ke}=Ye,{WrappedValue:ko}=No,{peekNodeInfo:xl}=Ne,{DEFAULT_VALUE:we,DefaultValue:Re,getConfigDeletionHandler:Io,registerNode:Ol,setConfigDeletionHandler:Bl}=_e,{isRecoilValue:zl}=Te,{getRecoilValueAsLoadable:Fl,markRecoilValueModified:Wl,setRecoilValue:kn,setRecoilValueLoadable:Kl}=ge,{retainedByOptionWithDefault:Gl}=Pe,Ge=e=>e instanceof ko?e.value:e;function Hl(e){const{key:t,persistence_UNSTABLE:n}=e,o=Gl(e.retainedBy_UNSTABLE);let r=0;function a(w){return Pt(w.then(U=>(i=ke(U),U)).catch(U=>{throw i=Ut(U),U}))}let i=K(e.default)?a(e.default):Pl(e.default)?e.default.state==="loading"?a(e.default.contents):e.default:ke(Ge(e.default));i.contents;let u;const d=new Map;function f(w){return w}function p(w,U){const Y=U.then(z=>{var G,q;return((q=((G=w.getState().nextTree)!==null&&G!==void 0?G:w.getState().currentTree).atomValues.get(t))===null||q===void 0?void 0:q.contents)===Y&&kn(w,te,z),z}).catch(z=>{var G,q;throw((q=((G=w.getState().nextTree)!==null&&G!==void 0?G:w.getState().currentTree).atomValues.get(t))===null||q===void 0?void 0:q.contents)===Y&&Kl(w,te,Ut(z)),z});return Y}function g(w,U,Y){var z;r++;const G=()=>{var J;r--,(J=d.get(w))===null||J===void 0||J.forEach(ue=>ue()),d.delete(w)};if(w.getState().knownAtoms.add(t),i.state==="loading"){const J=()=>{var ue;((ue=w.getState().nextTree)!==null&&ue!==void 0?ue:w.getState().currentTree).atomValues.has(t)||Wl(w,te)};i.contents.finally(J)}const q=(z=e.effects)!==null&&z!==void 0?z:e.effects_UNSTABLE;if(q!=null){let J=function(P){if(le&&P.key===t){const B=X;return B instanceof Re?D(w,U):K(B)?Pt(B.then(c=>c instanceof Re?i.toPromise():c)):ke(B)}return Fl(w,P)},ue=function(P){return J(P).toPromise()},Ce=function(P){var B;const c=xl(w,(B=w.getState().nextTree)!==null&&B!==void 0?B:w.getState().currentTree,P.key);return le&&P.key===t&&!(X instanceof Re)?{...c,isSet:!0,loadable:J(P)}:c},X=we,le=!0,be=!1,de=null;const Se=P=>B=>{if(le){const c=J(te),v=c.state==="hasValue"?c.contents:we;X=typeof B=="function"?B(v):B,K(X)&&(X=X.then(_=>(de={effect:P,value:_},_)))}else{if(K(B))throw M("Setting atoms to async values is not implemented.");typeof B!="function"&&(de={effect:P,value:Ge(B)}),kn(w,te,typeof B=="function"?c=>{const v=Ge(B(c));return de={effect:P,value:v},v}:Ge(B))}},Ve=P=>()=>Se(P)(we),$e=P=>B=>{var c;const{release:v}=w.subscribeToTransactions(_=>{var C;let{currentTree:R,previousTree:k}=_.getState();k||(ie(),k=R);const b=(C=R.atomValues.get(t))!==null&&C!==void 0?C:i;if(b.state==="hasValue"){var x,W,ee,O;const ne=b.contents,me=(x=k.atomValues.get(t))!==null&&x!==void 0?x:i,ce=me.state==="hasValue"?me.contents:we;((W=de)===null||W===void 0?void 0:W.effect)!==P||((ee=de)===null||ee===void 0?void 0:ee.value)!==ne?B(ne,ce,!R.atomValues.has(t)):((O=de)===null||O===void 0?void 0:O.effect)===P&&(de=null)}},t);d.set(w,[...(c=d.get(w))!==null&&c!==void 0?c:[],v])};for(const P of q)try{const B=P({node:te,storeID:w.storeID,parentStoreID_UNSTABLE:w.parentStoreID,trigger:Y,setSelf:Se(P),resetSelf:Ve(P),onSet:$e(P),getPromise:ue,getLoadable:J,getInfo_UNSTABLE:Ce});if(B!=null){var re;d.set(w,[...(re=d.get(w))!==null&&re!==void 0?re:[],B])}}catch(B){X=B,be=!0}if(le=!1,!(X instanceof Re)){var ye;const P=be?Ut(X):K(X)?Pt(p(w,X)):ke(Ge(X));P.contents,U.atomValues.set(t,P),(ye=w.getState().nextTree)===null||ye===void 0||ye.atomValues.set(t,P)}}return G}function D(w,U){var Y,z;return(Y=(z=U.atomValues.get(t))!==null&&z!==void 0?z:u)!==null&&Y!==void 0?Y:i}function L(w,U){if(U.atomValues.has(t))return j(U.atomValues.get(t));if(U.nonvalidatedAtoms.has(t)){if(u!=null)return u;if(n==null)return Fn(),i;const Y=U.nonvalidatedAtoms.get(t),z=n.validator(Y,we);return u=z instanceof Re?i:ke(z),u}else return i}function E(){u=void 0}function $(w,U,Y){if(U.atomValues.has(t)){const z=j(U.atomValues.get(t));if(z.state==="hasValue"&&Y===z.contents)return new Map}else if(!U.nonvalidatedAtoms.has(t)&&Y instanceof Re)return new Map;return u=void 0,new Map().set(t,ke(Y))}function Q(){return Io(t)!==void 0&&r<=0}const te=Ol({key:t,nodeType:"atom",peek:D,get:L,set:$,init:g,invalidate:E,shouldDeleteConfigOnRelease:Q,dangerouslyAllowMutability:e.dangerouslyAllowMutability,persistence_UNSTABLE:e.persistence_UNSTABLE?{type:e.persistence_UNSTABLE.type,backButton:e.persistence_UNSTABLE.backButton}:void 0,shouldRestoreFromSnapshots:!0,retainedBy:o});return te}function sn(e){const{...t}=e,n="default"in e?e.default:new Promise(()=>{});return zl(n)?jl({...t,default:n}):Hl({...t,default:n})}function jl(e){const t=sn({...e,default:we,persistence_UNSTABLE:e.persistence_UNSTABLE===void 0?void 0:{...e.persistence_UNSTABLE,validator:o=>o instanceof Re?o:j(e.persistence_UNSTABLE).validator(o,we)},effects:e.effects,effects_UNSTABLE:e.effects_UNSTABLE}),n=qe({key:`${e.key}__withFallback`,get:({get:o})=>{const r=o(t);return r instanceof Re?e.default:r},set:({set:o},r)=>o(t,r),cachePolicy_UNSTABLE:{eviction:"most-recent"},dangerouslyAllowMutability:e.dangerouslyAllowMutability});return Bl(n.key,Io(e.key)),n}sn.value=e=>new ko(e);var ql=sn;class Zl{constructor(t){var n;V(this,"_map",void 0),V(this,"_keyMapper",void 0),this._map=new Map,this._keyMapper=(n=t==null?void 0:t.mapKey)!==null&&n!==void 0?n:o=>o}size(){return this._map.size}has(t){return this._map.has(this._keyMapper(t))}get(t){return this._map.get(this._keyMapper(t))}set(t,n){this._map.set(this._keyMapper(t),n)}delete(t){this._map.delete(this._keyMapper(t))}clear(){this._map.clear()}}var Yl={MapCache:Zl},Xl=Yl.MapCache,Jl=Object.freeze({__proto__:null,MapCache:Xl});const{LRUCache:In}=Co,{MapCache:Ql}=Jl,it={equality:"reference",eviction:"none",maxSize:1/0};function ec({equality:e=it.equality,eviction:t=it.eviction,maxSize:n=it.maxSize}=it){const o=tc(e);return nc(t,n,o)}function tc(e){switch(e){case"reference":return t=>t;case"value":return t=>an(t)}throw M(`Unrecognized equality policy ${e}`)}function nc(e,t,n){switch(e){case"keep-all":return new Ql({mapKey:n});case"lru":return new In({mapKey:n,maxSize:j(t)});case"most-recent":return new In({mapKey:n,maxSize:1})}throw M(`Unrecognized eviction policy ${e}`)}var oc=ec;const{setConfigDeletionHandler:rc}=_e;let ac=0;function sc(e){var t,n;const o=oc({equality:(t=(n=e.cachePolicyForParams_UNSTABLE)===null||n===void 0?void 0:n.equality)!==null&&t!==void 0?t:"value",eviction:"keep-all"});return r=>{var a;let i;try{i=o.get(r)}catch(D){throw M(`Problem with cache lookup for selector ${e.key}: ${D.message}`)}if(i!=null)return i;const u=`${e.key}__selectorFamily/${(a=an(r,{allowFunctions:!0}))!==null&&a!==void 0?a:"void"}/${ac++}`,d=D=>e.get(r)(D),f=e.cachePolicy_UNSTABLE,p=typeof e.retainedBy_UNSTABLE=="function"?e.retainedBy_UNSTABLE(r):e.retainedBy_UNSTABLE;let g;if(e.set!=null){const D=e.set;g=qe({key:u,get:d,set:(E,$)=>D(r)(E,$),cachePolicy_UNSTABLE:f,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:p})}else g=qe({key:u,get:d,cachePolicy_UNSTABLE:f,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:p});return o.set(r,g),rc(g.key,()=>{o.delete(r)}),g}}var Le=sc;Le({key:"__constant",get:e=>()=>e,cachePolicyForParams_UNSTABLE:{equality:"reference"}});Le({key:"__error",get:e=>()=>{throw M(e)},cachePolicyForParams_UNSTABLE:{equality:"reference"}});const{loadableWithError:Do,loadableWithPromise:Uo,loadableWithValue:Po}=Ye;function Et(e,t){const n=Array(t.length).fill(void 0),o=Array(t.length).fill(void 0);for(const[r,a]of t.entries())try{n[r]=e(a)}catch(i){o[r]=i}return[n,o]}function ic(e){return e!=null&&!K(e)}function Tt(e){return Array.isArray(e)?e:Object.getOwnPropertyNames(e).map(t=>e[t])}function Kt(e,t){return Array.isArray(e)?t:Object.getOwnPropertyNames(e).reduce((n,o,r)=>({...n,[o]:t[r]}),{})}function Ie(e,t,n){const o=n.map((r,a)=>r==null?Po(t[a]):K(r)?Uo(r):Do(r));return Kt(e,o)}function lc(e,t){return t.map((n,o)=>n===void 0?e[o]:n)}Le({key:"__waitForNone",get:e=>({get:t})=>{const n=Tt(e),[o,r]=Et(t,n);return Ie(e,o,r)},dangerouslyAllowMutability:!0});Le({key:"__waitForAny",get:e=>({get:t})=>{const n=Tt(e),[o,r]=Et(t,n);return r.some(a=>!K(a))?Ie(e,o,r):new Promise(a=>{for(const[i,u]of r.entries())K(u)&&u.then(d=>{o[i]=d,r[i]=void 0,a(Ie(e,o,r))}).catch(d=>{r[i]=d,a(Ie(e,o,r))})})},dangerouslyAllowMutability:!0});Le({key:"__waitForAll",get:e=>({get:t})=>{const n=Tt(e),[o,r]=Et(t,n);if(r.every(i=>i==null))return Kt(e,o);const a=r.find(ic);if(a!=null)throw a;return Promise.all(r).then(i=>Kt(e,lc(o,i)))},dangerouslyAllowMutability:!0});Le({key:"__waitForAllSettled",get:e=>({get:t})=>{const n=Tt(e),[o,r]=Et(t,n);return r.every(a=>!K(a))?Ie(e,o,r):Promise.all(r.map((a,i)=>K(a)?a.then(u=>{o[i]=u,r[i]=void 0}).catch(u=>{o[i]=void 0,r[i]=u}):null)).then(()=>Ie(e,o,r))},dangerouslyAllowMutability:!0});Le({key:"__noWait",get:e=>({get:t})=>{try{return qe.value(Po(t(e)))}catch(n){return qe.value(K(n)?Uo(n):Do(n))}},dangerouslyAllowMutability:!0});const{RecoilLoadable:Cc}=Ye,{RecoilRoot:cc}=rn,{isRecoilValue:Vc}=Te,{freshSnapshot:$c}=gt,{useRecoilState:uc,useSetRecoilState:dc}=Vi;var At={RecoilRoot:cc,atom:ql,useRecoilState:uc,useSetRecoilState:dc},Mc=At.RecoilRoot,fc=At.atom,kc=At.useRecoilState,Ic=At.useSetRecoilState;const Dc=fc({key:"ProgrammingLanguage",default:{language:"java"}});export{Mc as R,kc as a,Ic as b,Dc as p};
